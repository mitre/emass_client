/* tslint:disable */
/* eslint-disable */
/**
 * Enterprise Mission Assurance Support Service (eMASS)
 * The Enterprise Mission Assurance Support Service (eMASS) Representational State Transfer (REST) Application Programming Interface (API) enables users to perform assessments and complete actions associated with system records.   <strong>Register External Application (that use the eMASS API)</strong></br> New users will need to [register](https://nisp.emass.apps.mil/Content/Help/jobaids/eMASS_OT_NewUser_Job_Aid.pdf) an API key with the eMASS development team prior to accessing the site for the first time. The eMASS REST API requires a client certificate (SSL/TLS, DoD PKI only). Use the `Registration` endpoint to register the client certificate.</br></br>  Every call to the eMASS REST API will require the use of the agreed upon public key certificate and API key. The API key must be provided in the request header for all endpoint calls (api-key). If the service receives an untrusted certificate or API key, a 401 error response code will be returned along with an error message.</br></br>  <strong>Available Request Headers</strong></br> <table>   <tr>     <th align=left>key</th>     <th align=left>Example Value</th>     <th align=left>Description</th>   </tr>   <tr>     <td>`api-key`</td>     <td>api-key-provided-by-emass</td>     <td>This API key must be provided in the request header for all endpoint calls</td>   </tr>   <tr>     <td>`user-uid`</td>     <td>USER.UID.KEY</td>     <td>This User unique identifier key must be provided in the request header for all PUT, POST, and DELETE endpoint calls</td>   </tr>   <tr>     <td></td><td></td>     <td>       Note: For DoD users this is the DoD ID Number (EIDIPI) on their DoD CAC     </td>   </tr> </table>  </br><strong>Approve API Client for Actionable Requests</strong></br> Users are required to log-in to eMASS and grant permissions for a client to update data within eMASS on their behalf. This is only required for actionable requests (PUT, POST, DELETE). The Registration Endpoint and all GET requests can be accessed without completing this process with the correct permissions. Please note that leaving a field parameter blank (for PUT/POST requests) has the potential to clear information in the active eMASS records.  To establish an account with eMASS and/or acquire an api-key/user-uid, contact one of the listed POC: 
 *
 * The version of the OpenAPI document: v3.3
 * Contact: disa.meade.id.mbx.emass-tier-iii-support@mail.mil
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ArtifactsGet
 */
export interface ArtifactsGet {
    /**
     * [Required] Unique eMASS system identifier.
     * @type {number}
     * @memberof ArtifactsGet
     */
    'systemId'?: number;
    /**
     * [Required] File name should match exactly one file within the provided zip file. 1000 Characters.
     * @type {string}
     * @memberof ArtifactsGet
     */
    'filename'?: string;
    /**
     * [Read-only] Indicates whether an artifact is inherited.
     * @type {boolean}
     * @memberof ArtifactsGet
     */
    'isInherited'?: boolean | null;
    /**
     * [Required] Indicates whether an artifact template.
     * @type {boolean}
     * @memberof ArtifactsGet
     */
    'isTemplate'?: boolean | null;
    /**
     * [Required] Artifact type options
     * @type {string}
     * @memberof ArtifactsGet
     */
    'type'?: ArtifactsGetTypeEnum;
    /**
     * [Required] Artifact category options
     * @type {string}
     * @memberof ArtifactsGet
     */
    'category'?: ArtifactsGetCategoryEnum;
    /**
     * [Optional] Artifact description. 2000 Characters.
     * @type {string}
     * @memberof ArtifactsGet
     */
    'description'?: string | null;
    /**
     * [Optional] Artifact reference page number. 50 Characters.
     * @type {string}
     * @memberof ArtifactsGet
     */
    'refPageNumber'?: string | null;
    /**
     * [Optional] CCI associated with test result.
     * @type {string}
     * @memberof ArtifactsGet
     */
    'ccis'?: string | null;
    /**
     * [Optional] Control acronym associated with the artifact. NIST SP 800-53 Revision 4 defined.
     * @type {string}
     * @memberof ArtifactsGet
     */
    'controls'?: string | null;
    /**
     * [Read-Only] Standard MIME content type derived from file extension.
     * @type {string}
     * @memberof ArtifactsGet
     */
    'mimeContentType'?: string | null;
    /**
     * [Read-Only] File size of attached artifact.
     * @type {string}
     * @memberof ArtifactsGet
     */
    'fileSize'?: string | null;
    /**
     * [Optional] Date Artifact expires and requires review. In Unix Date format.
     * @type {number}
     * @memberof ArtifactsGet
     */
    'artifactExpirationDate'?: number | null;
    /**
     * [Conditional] Date Artifact was last reviewed.. Unix time format.
     * @type {number}
     * @memberof ArtifactsGet
     */
    'lastReviewedDate'?: number | null;
}

export const ArtifactsGetTypeEnum = {
    Procedure: 'Procedure',
    Diagram: 'Diagram',
    Policy: 'Policy',
    Labor: 'Labor',
    Document: 'Document',
    Image: 'Image',
    Other: 'Other',
    ScanResult: 'Scan Result',
    AuditorReport: 'Auditor Report',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ArtifactsGetTypeEnum = typeof ArtifactsGetTypeEnum[keyof typeof ArtifactsGetTypeEnum];
export const ArtifactsGetCategoryEnum = {
    ImplementationGuidance: 'Implementation Guidance',
    Evidence: 'Evidence',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ArtifactsGetCategoryEnum = typeof ArtifactsGetCategoryEnum[keyof typeof ArtifactsGetCategoryEnum];

/**
 * 
 * @export
 * @interface ArtifactsResponseDel
 */
export interface ArtifactsResponseDel {
    /**
     * 
     * @type {Response200}
     * @memberof ArtifactsResponseDel
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<ArtifactsResponseDelDataInner>}
     * @memberof ArtifactsResponseDel
     */
    'data'?: Array<ArtifactsResponseDelDataInner>;
}
/**
 * 
 * @export
 * @interface ArtifactsResponseDelDataInner
 */
export interface ArtifactsResponseDelDataInner {
    /**
     * [Required] File name should match exactly one file within the provided zip file. 1000 Characters.
     * @type {string}
     * @memberof ArtifactsResponseDelDataInner
     */
    'filename'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ArtifactsResponseDelDataInner
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ArtifactsResponseDelDataInner
     */
    'systemId'?: number;
}
/**
 * 
 * @export
 * @interface ArtifactsResponseGet
 */
export interface ArtifactsResponseGet {
    /**
     * 
     * @type {Response200}
     * @memberof ArtifactsResponseGet
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<ArtifactsGet>}
     * @memberof ArtifactsResponseGet
     */
    'data'?: Array<ArtifactsGet>;
}
/**
 * 
 * @export
 * @interface ArtifactsResponsePutPost
 */
export interface ArtifactsResponsePutPost {
    /**
     * 
     * @type {Response200}
     * @memberof ArtifactsResponsePutPost
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<ArtifactsResponsePutPostDataInner>}
     * @memberof ArtifactsResponsePutPost
     */
    'data'?: Array<ArtifactsResponsePutPostDataInner>;
}
/**
 * 
 * @export
 * @interface ArtifactsResponsePutPostDataInner
 */
export interface ArtifactsResponsePutPostDataInner {
    /**
     * [Required] File name should match exactly one file within the provided zip file. 1000 Characters.
     * @type {string}
     * @memberof ArtifactsResponsePutPostDataInner
     */
    'filename'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ArtifactsResponsePutPostDataInner
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ArtifactsResponsePutPostDataInner
     */
    'systemId'?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof ArtifactsResponsePutPostDataInner
     */
    'errors'?: Array<any> | null;
}
/**
 * 
 * @export
 * @interface CacGet
 */
export interface CacGet {
    /**
     * [Required] Unique eMASS system identifier.
     * @type {number}
     * @memberof CacGet
     */
    'systemId'?: number;
    /**
     * [Required] System acronym name.
     * @type {string}
     * @memberof CacGet
     */
    'controlAcronym'?: string;
    /**
     * [Read-only] Compliance status of the control.
     * @type {string}
     * @memberof CacGet
     */
    'complianceStatus'?: string | null;
    /**
     * [Read-Only] Role in current stage.
     * @type {string}
     * @memberof CacGet
     */
    'currentStageName'?: string | null;
    /**
     * [Read-Only] Current step in the Control Approval Chain.
     * @type {number}
     * @memberof CacGet
     */
    'currentStage'?: number | null;
    /**
     * [Read-Only] Total number of steps in Control Approval Chain.
     * @type {number}
     * @memberof CacGet
     */
    'totalStages'?: number | null;
    /**
     * [Conditional] Control Approval Chain comments - 2000 Characters.
     * @type {string}
     * @memberof CacGet
     */
    'comments'?: string | null;
}
/**
 * 
 * @export
 * @interface CacResponseGet
 */
export interface CacResponseGet {
    /**
     * 
     * @type {Response200}
     * @memberof CacResponseGet
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<CacGet>}
     * @memberof CacResponseGet
     */
    'data'?: Array<CacGet>;
}
/**
 * 
 * @export
 * @interface CacResponsePost
 */
export interface CacResponsePost {
    /**
     * 
     * @type {Response200}
     * @memberof CacResponsePost
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<CacResponsePostDataInner>}
     * @memberof CacResponsePost
     */
    'data'?: Array<CacResponsePostDataInner>;
}
/**
 * 
 * @export
 * @interface CacResponsePostDataInner
 */
export interface CacResponsePostDataInner {
    /**
     * [Required] System acronym name.
     * @type {string}
     * @memberof CacResponsePostDataInner
     */
    'controlAcronym'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CacResponsePostDataInner
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CacResponsePostDataInner
     */
    'systemId'?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof CacResponsePostDataInner
     */
    'errors'?: Array<any> | null;
}
/**
 * 
 * @export
 * @interface CloudResourcesPost
 */
export interface CloudResourcesPost {
    /**
     * [Required] Unique identifier/resource namespace for policy compliance result
     * @type {string}
     * @memberof CloudResourcesPost
     */
    'resourceId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CloudResourcesPost
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CloudResourcesPost
     */
    'systemId'?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof CloudResourcesPost
     */
    'errors'?: Array<any> | null;
}
/**
 * 
 * @export
 * @interface CloudResourcesResponsePost
 */
export interface CloudResourcesResponsePost {
    /**
     * 
     * @type {Response200}
     * @memberof CloudResourcesResponsePost
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<CloudResourcesPost>}
     * @memberof CloudResourcesResponsePost
     */
    'data'?: Array<CloudResourcesPost>;
}
/**
 * 
 * @export
 * @interface CmmcGet
 */
export interface CmmcGet {
    /**
     * [Read-Only] Indicates the action that should be taken on the assessment record since the provided sinceDate.
     * @type {string}
     * @memberof CmmcGet
     */
    'operation'?: CmmcGetOperationEnum;
    /**
     * [Read-Only] The name of the DIB Company.
     * @type {string}
     * @memberof CmmcGet
     */
    'hqOrganizationName'?: string | null;
    /**
     * [Read-Only] The Data Universal Numbering System (DUNS) number.
     * @type {string}
     * @memberof CmmcGet
     */
    'duns'?: string | null;
    /**
     * [Read-Only] The Unique Entity Identifier assigned to the DIB Company.
     * @type {string}
     * @memberof CmmcGet
     */
    'uniqueEntityIdentifier'?: string | null;
    /**
     * [Read-Only] The five position code(s) associated with the Organization Seeking Certification (OSC).
     * @type {string}
     * @memberof CmmcGet
     */
    'cageCodes'?: string | null;
    /**
     * [Read-Only] The name of the Organization Seeking Certification.
     * @type {string}
     * @memberof CmmcGet
     */
    'oscName'?: string | null;
    /**
     * [Read-Only] The scope of the OSC assessment.
     * @type {string}
     * @memberof CmmcGet
     */
    'scope'?: string | null;
    /**
     * [Read-Only] Brief description of the scope of the OSC assessment
     * @type {string}
     * @memberof CmmcGet
     */
    'scopeDescription'?: string | null;
    /**
     * [Read-Only] The CMMC award level.
     * @type {string}
     * @memberof CmmcGet
     */
    'awardedCMMCLevel'?: string | null;
    /**
     * [Read-Only] Expiration date of the awarded CMMC certification.
     * @type {number}
     * @memberof CmmcGet
     */
    'expirationDate'?: number | null;
    /**
     * [Read-Only] Unique identifier for the assessment/certificate.
     * @type {string}
     * @memberof CmmcGet
     */
    'certificateId'?: string | null;
    /**
     * [Read-Only] Version of the CMMC Model used as part of the assessment.
     * @type {string}
     * @memberof CmmcGet
     */
    'modelVersion'?: string | null;
    /**
     * 
     * @type {Array<Ssps>}
     * @memberof CmmcGet
     */
    'ssps'?: Array<Ssps> | null;
}

export const CmmcGetOperationEnum = {
    Added: 'ADDED',
    Updated: 'UPDATED',
    Deleted: 'DELETED',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type CmmcGetOperationEnum = typeof CmmcGetOperationEnum[keyof typeof CmmcGetOperationEnum];

/**
 * 
 * @export
 * @interface CmmcResponseGet
 */
export interface CmmcResponseGet {
    /**
     * 
     * @type {Response200}
     * @memberof CmmcResponseGet
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<CmmcGet>}
     * @memberof CmmcResponseGet
     */
    'data'?: Array<CmmcGet>;
}
/**
 * 
 * @export
 * @interface ConnectivityCcsd
 */
export interface ConnectivityCcsd {
    /**
     * [Read-Only] Identifier for specific connections to the system.
     * @type {string}
     * @memberof ConnectivityCcsd
     */
    'ccsdNumber'?: string | null;
    /**
     * [Read-Only] Choose connection type for the system.
     * @type {string}
     * @memberof ConnectivityCcsd
     */
    'connectivity'?: string | null;
}
/**
 * 
 * @export
 * @interface ContainersResourcesPost
 */
export interface ContainersResourcesPost {
    /**
     * [Required] Unique identifier of the container
     * @type {string}
     * @memberof ContainersResourcesPost
     */
    'containerId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ContainersResourcesPost
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ContainersResourcesPost
     */
    'systemId'?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof ContainersResourcesPost
     */
    'errors'?: Array<any> | null;
}
/**
 * 
 * @export
 * @interface ContainersResponsePost
 */
export interface ContainersResponsePost {
    /**
     * 
     * @type {Response200}
     * @memberof ContainersResponsePost
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<ContainersResourcesPost>}
     * @memberof ContainersResponsePost
     */
    'data'?: Array<ContainersResourcesPost>;
}
/**
 * 
 * @export
 * @interface ControlsGet
 */
export interface ControlsGet {
    /**
     * [Required] Unique system record identifier.
     * @type {number}
     * @memberof ControlsGet
     */
    'systemId'?: number;
    /**
     * [Read-only] Name of the system record.
     * @type {string}
     * @memberof ControlsGet
     */
    'name'?: string | null;
    /**
     * [Required] Acronym of the system record.
     * @type {string}
     * @memberof ControlsGet
     */
    'acronym'?: string;
    /**
     * [Read-only] Comma separated list of CCIs associated with the control.
     * @type {string}
     * @memberof ControlsGet
     */
    'ccis'?: string | null;
    /**
     * [Read-only] Indicates whether a control is inherited.
     * @type {boolean}
     * @memberof ControlsGet
     */
    'isInherited'?: boolean | null;
    /**
     * [Read-only] List of overlays that affect the control.
     * @type {string}
     * @memberof ControlsGet
     */
    'modifiedByOverlays'?: ControlsGetModifiedByOverlaysEnum;
    /**
     * [Read-only] Indicates the manner by which a control was included in the system’s categorization.
     * @type {string}
     * @memberof ControlsGet
     */
    'includedStatus'?: string | null;
    /**
     * [Read-only] Compliance of the control.
     * @type {string}
     * @memberof ControlsGet
     */
    'complianceStatus'?: string | null;
    /**
     * [Required] Include written description of Responsible Entities that are responsible for the Security Control. Character Limit = 2,000.
     * @type {string}
     * @memberof ControlsGet
     */
    'responsibleEntities'?: string;
    /**
     * [Optional] Implementation Status of the Security Control for the information system.
     * @type {string}
     * @memberof ControlsGet
     */
    'implementationStatus'?: ControlsGetImplementationStatusEnum;
    /**
     * [Conditional] Indicate the type of Common Control Provider for an “Inherited” Security Control.
     * @type {string}
     * @memberof ControlsGet
     */
    'commonControlProvider'?: ControlsGetCommonControlProviderEnum;
    /**
     * [Conditional] Provide justification for Security Controls deemed Not Applicable to the system.
     * @type {string}
     * @memberof ControlsGet
     */
    'naJustification'?: string | null;
    /**
     * [Required] Control designations
     * @type {string}
     * @memberof ControlsGet
     */
    'controlDesignation'?: ControlsGetControlDesignationEnum;
    /**
     * [Required] Field is required for Implementation Plan.
     * @type {number}
     * @memberof ControlsGet
     */
    'estimatedCompletionDate'?: number;
    /**
     * [Required] Includes security control comments. Character Limit = 2,000.
     * @type {string}
     * @memberof ControlsGet
     */
    'implementationNarrative'?: string;
    /**
     * [Conditional] Criticality of Security Control regarding SLCM. Character Limit = 2,000.
     * @type {string}
     * @memberof ControlsGet
     */
    'slcmCriticality'?: string | null;
    /**
     * [Conditional] SLCM frequency
     * @type {string}
     * @memberof ControlsGet
     */
    'slcmFrequency'?: ControlsGetSlcmFrequencyEnum;
    /**
     * [Conditional] SLCM method utilized
     * @type {string}
     * @memberof ControlsGet
     */
    'slcmMethod'?: ControlsGetSlcmMethodEnum;
    /**
     * [Conditional] Method for reporting Security Control for SLCM. Character Limit = 2,000.
     * @type {string}
     * @memberof ControlsGet
     */
    'slcmReporting'?: string | null;
    /**
     * [Conditional] How Non-Compliant Security Controls will be tracked for SLCM. Character Limit = 2,000.
     * @type {string}
     * @memberof ControlsGet
     */
    'slcmTracking'?: string | null;
    /**
     * [Conditional] Additional comments for Security Control regarding SLCM. Character Limit = 4,000.
     * @type {string}
     * @memberof ControlsGet
     */
    'slcmComments'?: string | null;
    /**
     * [Optional] Values include the following options (Very Low, Low, Moderate,High,Very High)
     * @type {string}
     * @memberof ControlsGet
     */
    'severity'?: ControlsGetSeverityEnum;
    /**
     * [Optional] Include vulnerability summary. Character Limit = 2,000.
     * @type {string}
     * @memberof ControlsGet
     */
    'vulnerabiltySummary'?: string | null;
    /**
     * [Optional] Include recommendations. Character Limit = 2,000.
     * @type {string}
     * @memberof ControlsGet
     */
    'recommendations'?: string | null;
    /**
     * [Optional] Values include the following options (Very Low, Low, Moderate,High,Very High)
     * @type {string}
     * @memberof ControlsGet
     */
    'relevanceOfThreat'?: ControlsGetRelevanceOfThreatEnum;
    /**
     * [Optional] Values include the following options (Very Low, Low, Moderate,High,Very High)
     * @type {string}
     * @memberof ControlsGet
     */
    'likelihood'?: ControlsGetLikelihoodEnum;
    /**
     * [Optional] Values include the following options (Very Low, Low, Moderate,High,Very High)
     * @type {string}
     * @memberof ControlsGet
     */
    'impact'?: ControlsGetImpactEnum;
    /**
     * [Optional] Include description of Security Control’s impact.
     * @type {string}
     * @memberof ControlsGet
     */
    'impactDescription'?: string | null;
    /**
     * [Optional] Values include the following options (Very Low, Low, Moderate,High,Very High)
     * @type {string}
     * @memberof ControlsGet
     */
    'residualRiskLevel'?: ControlsGetResidualRiskLevelEnum;
    /**
     * [Optional] Identifies the assessment method / combination that will determine if the security requirements are implemented correctly.
     * @type {string}
     * @memberof ControlsGet
     */
    'testMethod'?: ControlsGetTestMethodEnum;
}

export const ControlsGetModifiedByOverlaysEnum = {
    Privacy: 'Privacy',
    Requirements: 'Requirements',
    Concurrency: 'Concurrency',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ControlsGetModifiedByOverlaysEnum = typeof ControlsGetModifiedByOverlaysEnum[keyof typeof ControlsGetModifiedByOverlaysEnum];
export const ControlsGetImplementationStatusEnum = {
    Planned: 'Planned',
    Implemented: 'Implemented',
    Inherited: 'Inherited',
    NotApplicable: 'Not Applicable',
    ManuallyInherited: 'Manually Inherited',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ControlsGetImplementationStatusEnum = typeof ControlsGetImplementationStatusEnum[keyof typeof ControlsGetImplementationStatusEnum];
export const ControlsGetCommonControlProviderEnum = {
    DoD: 'DoD',
    Component: 'Component',
    Enclave: 'Enclave',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ControlsGetCommonControlProviderEnum = typeof ControlsGetCommonControlProviderEnum[keyof typeof ControlsGetCommonControlProviderEnum];
export const ControlsGetControlDesignationEnum = {
    Common: 'Common',
    SystemSpecific: 'System-Specific',
    Hybrid: 'Hybrid',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ControlsGetControlDesignationEnum = typeof ControlsGetControlDesignationEnum[keyof typeof ControlsGetControlDesignationEnum];
export const ControlsGetSlcmFrequencyEnum = {
    Constantly: 'Constantly',
    Daily: 'Daily',
    Weekly: 'Weekly',
    Monthly: 'Monthly',
    Quarterly: 'Quarterly',
    SemiAnnually: 'Semi-Annually',
    Annually: 'Annually',
    EveryTwoYears: 'Every Two Years',
    EveryThreeYears: 'Every Three Years',
    Undetermined: 'Undetermined',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ControlsGetSlcmFrequencyEnum = typeof ControlsGetSlcmFrequencyEnum[keyof typeof ControlsGetSlcmFrequencyEnum];
export const ControlsGetSlcmMethodEnum = {
    Automated: 'Automated',
    SemiAutomated: 'Semi-Automated',
    Manual: 'Manual',
    Undetermined: 'Undetermined',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ControlsGetSlcmMethodEnum = typeof ControlsGetSlcmMethodEnum[keyof typeof ControlsGetSlcmMethodEnum];
export const ControlsGetSeverityEnum = {
    VeryLow: 'Very Low',
    Low: 'Low',
    Moderate: 'Moderate',
    High: 'High',
    VeryHigh: 'Very High',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ControlsGetSeverityEnum = typeof ControlsGetSeverityEnum[keyof typeof ControlsGetSeverityEnum];
export const ControlsGetRelevanceOfThreatEnum = {
    VeryLow: 'Very Low',
    Low: 'Low',
    Moderate: 'Moderate',
    High: 'High',
    VeryHigh: 'Very High',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ControlsGetRelevanceOfThreatEnum = typeof ControlsGetRelevanceOfThreatEnum[keyof typeof ControlsGetRelevanceOfThreatEnum];
export const ControlsGetLikelihoodEnum = {
    VeryLow: 'Very Low',
    Low: 'Low',
    Moderate: 'Moderate',
    High: 'High',
    VeryHigh: 'Very High',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ControlsGetLikelihoodEnum = typeof ControlsGetLikelihoodEnum[keyof typeof ControlsGetLikelihoodEnum];
export const ControlsGetImpactEnum = {
    VeryLow: 'Very Low',
    Low: 'Low',
    Moderate: 'Moderate',
    High: 'High',
    VeryHigh: 'Very High',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ControlsGetImpactEnum = typeof ControlsGetImpactEnum[keyof typeof ControlsGetImpactEnum];
export const ControlsGetResidualRiskLevelEnum = {
    VeryLow: 'Very Low',
    Low: 'Low',
    Moderate: 'Moderate',
    High: 'High',
    VeryHigh: 'Very High',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ControlsGetResidualRiskLevelEnum = typeof ControlsGetResidualRiskLevelEnum[keyof typeof ControlsGetResidualRiskLevelEnum];
export const ControlsGetTestMethodEnum = {
    Test: 'Test',
    Interview: 'Interview',
    Examine: 'Examine',
    TestInterview: 'Test, Interview',
    TestExamine: 'Test, Examine',
    InterviewExamine: 'Interview, Examine',
    TestInterviewExamine: 'Test, Interview, Examine',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ControlsGetTestMethodEnum = typeof ControlsGetTestMethodEnum[keyof typeof ControlsGetTestMethodEnum];

/**
 * 
 * @export
 * @interface ControlsPut
 */
export interface ControlsPut {
    /**
     * Acronym of the system record.
     * @type {string}
     * @memberof ControlsPut
     */
    'acronym'?: string;
    /**
     * Indicates if operations result (success/fail)
     * @type {boolean}
     * @memberof ControlsPut
     */
    'success'?: boolean;
    /**
     * The system identifier for the system being updated.
     * @type {number}
     * @memberof ControlsPut
     */
    'systemId'?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof ControlsPut
     */
    'errors'?: Array<any> | null;
}
/**
 * 
 * @export
 * @interface ControlsResponseGet
 */
export interface ControlsResponseGet {
    /**
     * 
     * @type {Response200}
     * @memberof ControlsResponseGet
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<ControlsGet>}
     * @memberof ControlsResponseGet
     */
    'data'?: Array<ControlsGet> | null;
}
/**
 * 
 * @export
 * @interface ControlsResponsePut
 */
export interface ControlsResponsePut {
    /**
     * 
     * @type {Response200}
     * @memberof ControlsResponsePut
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<ControlsPut>}
     * @memberof ControlsResponsePut
     */
    'data'?: Array<ControlsPut>;
}
/**
 * 
 * @export
 * @interface DefinitionTransitions
 */
export interface DefinitionTransitions {
    /**
     * [Read-Only] The landing stage that is active after performing a transition.
     * @type {string}
     * @memberof DefinitionTransitions
     */
    'endStage'?: string | null;
    /**
     * [Read-Only] Description that matches the action dropdown that appears for PAC users.
     * @type {string}
     * @memberof DefinitionTransitions
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof DefinitionTransitions
     */
    'roles'?: Array<any> | null;
}
/**
 * 
 * @export
 * @interface DeleteArtifactsInner
 */
export interface DeleteArtifactsInner {
    /**
     * [Required] File name should match exactly one file within the provided zip file. 1000 Characters.
     * @type {string}
     * @memberof DeleteArtifactsInner
     */
    'filename'?: string;
}
/**
 * 
 * @export
 * @interface DeletePoamsInner
 */
export interface DeletePoamsInner {
    /**
     * [Required] Unique item identifier
     * @type {number}
     * @memberof DeletePoamsInner
     */
    'poamId'?: number;
}
/**
 * 
 * @export
 * @interface DeletePoamsInner1
 */
export interface DeletePoamsInner1 {
    /**
     * [Required] Unique item identifier
     * @type {number}
     * @memberof DeletePoamsInner1
     */
    'milestoneId'?: number;
}
/**
 * 
 * @export
 * @interface InstancesTransitions
 */
export interface InstancesTransitions {
    /**
     * [Read-Only] Comments entered by the user when performing the transition.
     * @type {string}
     * @memberof InstancesTransitions
     */
    'comments'?: string | null;
    /**
     * [Read-Only] User that performed the workflow transition.
     * @type {string}
     * @memberof InstancesTransitions
     */
    'createdBy'?: string | null;
    /**
     * [Read-Only] Date the workflow instance or the workflow transition was created.
     * @type {number}
     * @memberof InstancesTransitions
     */
    'createdDate'?: number | null;
    /**
     * [Read-Only] Description of the stage transition. This matches the action dropdown that appears for PAC users.
     * @type {string}
     * @memberof InstancesTransitions
     */
    'description'?: string | null;
    /**
     * [Read-Only] The landing stage that is active after performing a transition.
     * @type {string}
     * @memberof InstancesTransitions
     */
    'endStage'?: string | null;
    /**
     * [Read-Only] The beginning stage that is active before performing a transition.
     * @type {string}
     * @memberof InstancesTransitions
     */
    'startStage'?: string | null;
}
/**
 * 
 * @export
 * @interface MilestoneResponseGet
 */
export interface MilestoneResponseGet {
    /**
     * 
     * @type {Response200}
     * @memberof MilestoneResponseGet
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<MilestonesGet>}
     * @memberof MilestoneResponseGet
     */
    'data'?: Array<MilestonesGet>;
}
/**
 * 
 * @export
 * @interface MilestoneResponseGetMilestone
 */
export interface MilestoneResponseGetMilestone {
    /**
     * 
     * @type {Response200}
     * @memberof MilestoneResponseGetMilestone
     */
    'meta'?: Response200;
    /**
     * 
     * @type {MilestonesGet}
     * @memberof MilestoneResponseGetMilestone
     */
    'data'?: MilestonesGet;
}
/**
 * 
 * @export
 * @interface MilestoneResponsePost
 */
export interface MilestoneResponsePost {
    /**
     * 
     * @type {Response200}
     * @memberof MilestoneResponsePost
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<MilestonesPutPostDelete>}
     * @memberof MilestoneResponsePost
     */
    'data'?: Array<MilestonesPutPostDelete>;
}
/**
 * 
 * @export
 * @interface MilestoneResponsePut
 */
export interface MilestoneResponsePut {
    /**
     * 
     * @type {Response200}
     * @memberof MilestoneResponsePut
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<MilestonesPutPostDelete>}
     * @memberof MilestoneResponsePut
     */
    'data'?: Array<MilestonesPutPostDelete>;
}
/**
 * 
 * @export
 * @interface MilestonesGet
 */
export interface MilestonesGet {
    /**
     * [Required] Unique eMASS system identifier.
     * @type {number}
     * @memberof MilestonesGet
     */
    'systemId'?: number;
    /**
     * [Required] Unique item identifier
     * @type {number}
     * @memberof MilestonesGet
     */
    'milestoneId'?: number;
    /**
     * [Required] Unique item identifier
     * @type {number}
     * @memberof MilestonesGet
     */
    'poamId'?: number;
    /**
     * [Required] Include milestone description.
     * @type {string}
     * @memberof MilestonesGet
     */
    'description'?: string;
    /**
     * [Required] Required for ongoing and completed POA&M items. Unix time format.
     * @type {number}
     * @memberof MilestonesGet
     */
    'scheduledCompletionDate'?: number;
    /**
     * [Read-Only] Values include the following options: (Not Approved,Under Review,Approved)
     * @type {string}
     * @memberof MilestonesGet
     */
    'reviewStatus'?: MilestonesGetReviewStatusEnum;
}

export const MilestonesGetReviewStatusEnum = {
    NotApproved: 'Not Approved',
    UnderReview: 'Under Review',
    Approved: 'Approved',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type MilestonesGetReviewStatusEnum = typeof MilestonesGetReviewStatusEnum[keyof typeof MilestonesGetReviewStatusEnum];

/**
 * 
 * @export
 * @interface MilestonesPutPostDelete
 */
export interface MilestonesPutPostDelete {
    /**
     * The system identifier that the POAM was added.
     * @type {number}
     * @memberof MilestonesPutPostDelete
     */
    'systemId'?: number;
    /**
     * The newly created POAM identifier
     * @type {number}
     * @memberof MilestonesPutPostDelete
     */
    'poamId'?: number;
    /**
     * The Milestone unique item identifier
     * @type {number}
     * @memberof MilestonesPutPostDelete
     */
    'milestoneId'?: number;
    /**
     * The unique identifier external to the eMASS application for use with associating POA&Ms. 100 Characters.
     * @type {string}
     * @memberof MilestonesPutPostDelete
     */
    'externalUid'?: string;
    /**
     * Indicates if operations result (success/fail)
     * @type {boolean}
     * @memberof MilestonesPutPostDelete
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof MilestonesPutPostDelete
     */
    'errors'?: Array<any> | null;
}
/**
 * 
 * @export
 * @interface MilestonesRequiredPost
 */
export interface MilestonesRequiredPost {
    /**
     * [Required] Include milestone description.
     * @type {string}
     * @memberof MilestonesRequiredPost
     */
    'description': string;
    /**
     * [Required] Required for ongoing and completed POA&M items. Unix time format.
     * @type {number}
     * @memberof MilestonesRequiredPost
     */
    'scheduledCompletionDate': number;
}
/**
 * 
 * @export
 * @interface MilestonesRequiredPut
 */
export interface MilestonesRequiredPut {
    /**
     * [Required] Unique item identifier
     * @type {number}
     * @memberof MilestonesRequiredPut
     */
    'milestoneId': number;
    /**
     * [Required] Include milestone description.
     * @type {string}
     * @memberof MilestonesRequiredPut
     */
    'description': string;
    /**
     * [Required] Shecdule completion date. Unix time format.
     * @type {number}
     * @memberof MilestonesRequiredPut
     */
    'scheduledCompletionDate': number;
}
/**
 * 
 * @export
 * @interface PacGet
 */
export interface PacGet {
    /**
     * [Required] Unique eMASS system identifier.
     * @type {number}
     * @memberof PacGet
     */
    'systemId'?: number;
    /**
     * [Required] Values include the following:(Assess and Authorize, Assess Only, Security Plan Approval)
     * @type {string}
     * @memberof PacGet
     */
    'workflow'?: PacGetWorkflowEnum;
    /**
     * [Required] Package name. 100 Characters.
     * @type {string}
     * @memberof PacGet
     */
    'name'?: string;
    /**
     * [Read-Only] Name of the current stage in the active workflow.
     * @type {string}
     * @memberof PacGet
     */
    'currentStageName'?: string | null;
    /**
     * [Read-Only] Number of the current stage in the active workflow.
     * @type {number}
     * @memberof PacGet
     */
    'currentStage'?: number | null;
    /**
     * [Read-Only] Total number of stages in the active workflow.
     * @type {number}
     * @memberof PacGet
     */
    'totalStages'?: number | null;
    /**
     * [Read-Only] Indicates the number of days at current workflow stage.
     * @type {number}
     * @memberof PacGet
     */
    'daysAtCurrentStage'?: number | null;
    /**
     * [Required] Comments related to package approval chain. Character Limit = 4,000.
     * @type {string}
     * @memberof PacGet
     */
    'comments'?: string;
}

export const PacGetWorkflowEnum = {
    AssessAndAuthorize: 'Assess and Authorize',
    AssessOnly: 'Assess Only',
    SecurityPlanApproval: 'Security Plan Approval',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type PacGetWorkflowEnum = typeof PacGetWorkflowEnum[keyof typeof PacGetWorkflowEnum];

/**
 * 
 * @export
 * @interface PacPost
 */
export interface PacPost {
    /**
     * [Required] Values include the following:(Assess and Authorize, Assess Only, Security Plan Approval)
     * @type {string}
     * @memberof PacPost
     */
    'workflow'?: PacPostWorkflowEnum;
    /**
     * 
     * @type {boolean}
     * @memberof PacPost
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PacPost
     */
    'systemId'?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof PacPost
     */
    'errors'?: Array<any> | null;
}

export const PacPostWorkflowEnum = {
    AssessAndAuthorize: 'Assess and Authorize',
    AssessOnly: 'Assess Only',
    SecurityPlanApproval: 'Security Plan Approval',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type PacPostWorkflowEnum = typeof PacPostWorkflowEnum[keyof typeof PacPostWorkflowEnum];

/**
 * 
 * @export
 * @interface PacResponseGet
 */
export interface PacResponseGet {
    /**
     * 
     * @type {Response200}
     * @memberof PacResponseGet
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<PacGet>}
     * @memberof PacResponseGet
     */
    'data'?: Array<PacGet> | null;
}
/**
 * 
 * @export
 * @interface PacResponsePost
 */
export interface PacResponsePost {
    /**
     * 
     * @type {Response200}
     * @memberof PacResponsePost
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<PacPost>}
     * @memberof PacResponsePost
     */
    'data'?: Array<PacPost>;
}
/**
 * 
 * @export
 * @interface PoamGet
 */
export interface PoamGet {
    /**
     * [Optional] Unique identifier external to the eMASS application for use with associating POA&Ms. 100 Characters.
     * @type {string}
     * @memberof PoamGet
     */
    'externalUid'?: string | null;
    /**
     * [Required] Unique eMASS system identifier.
     * @type {number}
     * @memberof PoamGet
     */
    'systemId'?: number;
    /**
     * [Required] Unique item identifier
     * @type {number}
     * @memberof PoamGet
     */
    'poamId'?: number;
    /**
     * [Required] Globally unique identifier for individual POA&M Items, seen on the front-end as “ID”.
     * @type {number}
     * @memberof PoamGet
     */
    'displayPoamId'?: number;
    /**
     * [Read-only] Indicates whether a test result is inherited.
     * @type {boolean}
     * @memberof PoamGet
     */
    'isInherited'?: boolean | null;
    /**
     * [Optional] System acronym name.
     * @type {string}
     * @memberof PoamGet
     */
    'controlAcronym'?: string | null;
    /**
     * [Optional] CCI associated with POA&M Item..
     * @type {string}
     * @memberof PoamGet
     */
    'cci'?: string | null;
    /**
     * [Required] Values include the following: (Ongoing,Risk Accepted,Completed,Not Applicable
     * @type {string}
     * @memberof PoamGet
     */
    'status'?: PoamGetStatusEnum;
    /**
     * [Read-Only] Values include the following options: (Not Approved,Under Review,Approved)
     * @type {string}
     * @memberof PoamGet
     */
    'reviewStatus'?: PoamGetReviewStatusEnum;
    /**
     * [Required] Provide a description of the POA&M Item. 2000 Characters.
     * @type {string}
     * @memberof PoamGet
     */
    'vulnerabilityDescription'?: string;
    /**
     * [Required] Include Source Identifying Vulnerability text. 2000 Characters.
     * @type {string}
     * @memberof PoamGet
     */
    'sourceIdentVuln'?: string;
    /**
     * [Optional] Security Checks that are associated with the POA&M.
     * @type {string}
     * @memberof PoamGet
     */
    'securityChecks'?: string | null;
    /**
     * 
     * @type {Array<MilestonesGet>}
     * @memberof PoamGet
     */
    'milestones'?: Array<MilestonesGet>;
    /**
     * [Required] Organization/Office represented. 100 Characters.
     * @type {string}
     * @memberof PoamGet
     */
    'pocOrganization'?: string;
    /**
     * [Conditional] First name of POC. 100 Characters.
     * @type {string}
     * @memberof PoamGet
     */
    'pocFirstName'?: string | null;
    /**
     * [Conditional] Last name of POC. 100 Characters.
     * @type {string}
     * @memberof PoamGet
     */
    'pocLastName'?: string | null;
    /**
     * [Conditional] Email address of POC. 100 Characters.
     * @type {string}
     * @memberof PoamGet
     */
    'pocEmail'?: string | null;
    /**
     * [Conditional] Phone number of POC. 100 Characters.
     * @type {string}
     * @memberof PoamGet
     */
    'pocPhoneNumber'?: string | null;
    /**
     * [Conditional] Required for approved items. Values include the following options (Very Low,Low,Moderate,High,Very High)
     * @type {string}
     * @memberof PoamGet
     */
    'severity'?: PoamGetSeverityEnum;
    /**
     * [Optional] Values include the following options (I,II,III)
     * @type {string}
     * @memberof PoamGet
     */
    'rawSeverity'?: PoamGetRawSeverityEnum;
    /**
     * [Optional] Values include the following options: (Very Low,Low,Moderate,High,Very High)
     * @type {string}
     * @memberof PoamGet
     */
    'relevanceOfThreat'?: PoamGetRelevanceOfThreatEnum;
    /**
     * [Optional] Values include the following options: (Very Low,Low,Moderate,High,Very High)
     * @type {string}
     * @memberof PoamGet
     */
    'likelihood'?: PoamGetLikelihoodEnum;
    /**
     * [Optional] Values include the following options: (Very Low,Low,Moderate,High,Very High)
     * @type {string}
     * @memberof PoamGet
     */
    'impact'?: PoamGetImpactEnum;
    /**
     * [Optional] Include description of Security Control’s impact.
     * @type {string}
     * @memberof PoamGet
     */
    'impactDescription'?: string | null;
    /**
     * [Optional] Values include the following options: (Very Low,Low,Moderate,High,Very High)
     * @type {string}
     * @memberof PoamGet
     */
    'residualRiskLevel'?: PoamGetResidualRiskLevelEnum;
    /**
     * [Optional] Include recommendations. Character Limit = 2,000.
     * @type {string}
     * @memberof PoamGet
     */
    'recommendations'?: string | null;
    /**
     * [Required] List of resources used. 250 Characters.
     * @type {string}
     * @memberof PoamGet
     */
    'resources'?: string;
    /**
     * [Conditional] Required for ongoing and completed POA&M items. Unix time format.
     * @type {number}
     * @memberof PoamGet
     */
    'scheduledCompletionDate'?: number | null;
    /**
     * [Conditional] Field is required for completed POA&M items. Unix time format.
     * @type {number}
     * @memberof PoamGet
     */
    'completionDate'?: number | null;
    /**
     * [Read-Only] Value returned for a POA&M Item with review status Approved” and has a milestone with a scheduled completion date that extends beyond the POA&M Item’s scheduled completion date. 
     * @type {number}
     * @memberof PoamGet
     */
    'extensionDate'?: number | null;
    /**
     * [Conditional] Field is required for completed and risk accepted POA&M items. 2000 Characters
     * @type {string}
     * @memberof PoamGet
     */
    'comments'?: string | null;
    /**
     * [Optional] Include mitigation explanation. 2000 Characters.
     * @type {string}
     * @memberof PoamGet
     */
    'mitigation'?: string | null;
    /**
     * [Conditional] Optionally used in PUT to delete milestones when updating a POA&M.
     * @type {boolean}
     * @memberof PoamGet
     */
    'isActive'?: boolean | null;
}

export const PoamGetStatusEnum = {
    Ongoing: 'Ongoing',
    RiskAccepted: 'Risk Accepted',
    Completed: 'Completed',
    NotApplicable: 'Not Applicable',
    Archived: 'Archived',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type PoamGetStatusEnum = typeof PoamGetStatusEnum[keyof typeof PoamGetStatusEnum];
export const PoamGetReviewStatusEnum = {
    NotApproved: 'Not Approved',
    UnderReview: 'Under Review',
    Approved: 'Approved',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type PoamGetReviewStatusEnum = typeof PoamGetReviewStatusEnum[keyof typeof PoamGetReviewStatusEnum];
export const PoamGetSeverityEnum = {
    VeryLow: 'Very Low',
    Low: 'Low',
    Moderate: 'Moderate',
    High: 'High',
    VeryHigh: 'Very High',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type PoamGetSeverityEnum = typeof PoamGetSeverityEnum[keyof typeof PoamGetSeverityEnum];
export const PoamGetRawSeverityEnum = {
    I: 'I',
    Ii: 'II',
    Iii: 'III',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type PoamGetRawSeverityEnum = typeof PoamGetRawSeverityEnum[keyof typeof PoamGetRawSeverityEnum];
export const PoamGetRelevanceOfThreatEnum = {
    VeryLow: 'Very Low',
    Low: 'Low',
    Moderate: 'Moderate',
    High: 'High',
    VeryHigh: 'Very High',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type PoamGetRelevanceOfThreatEnum = typeof PoamGetRelevanceOfThreatEnum[keyof typeof PoamGetRelevanceOfThreatEnum];
export const PoamGetLikelihoodEnum = {
    VeryLow: 'Very Low',
    Low: 'Low',
    Moderate: 'Moderate',
    High: 'High',
    VeryHigh: 'Very High',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type PoamGetLikelihoodEnum = typeof PoamGetLikelihoodEnum[keyof typeof PoamGetLikelihoodEnum];
export const PoamGetImpactEnum = {
    VeryLow: 'Very Low',
    Low: 'Low',
    Moderate: 'Moderate',
    High: 'High',
    VeryHigh: 'Very High',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type PoamGetImpactEnum = typeof PoamGetImpactEnum[keyof typeof PoamGetImpactEnum];
export const PoamGetResidualRiskLevelEnum = {
    VeryLow: 'Very Low',
    Low: 'Low',
    Moderate: 'Moderate',
    High: 'High',
    VeryHigh: 'Very High',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type PoamGetResidualRiskLevelEnum = typeof PoamGetResidualRiskLevelEnum[keyof typeof PoamGetResidualRiskLevelEnum];

/**
 * 
 * @export
 * @interface PoamPostPutDel
 */
export interface PoamPostPutDel {
    /**
     * The system identifier for the system being updated.
     * @type {number}
     * @memberof PoamPostPutDel
     */
    'systemId'?: number;
    /**
     * The newly created POAM identifier
     * @type {number}
     * @memberof PoamPostPutDel
     */
    'poamId'?: number;
    /**
     * The unique identifier external to the eMASS application for use with associating POA&Ms. 100 Characters.
     * @type {string}
     * @memberof PoamPostPutDel
     */
    'externalUid'?: string;
    /**
     * Indicates if operations result (success/fail)
     * @type {boolean}
     * @memberof PoamPostPutDel
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof PoamPostPutDel
     */
    'errors'?: Array<any> | null;
}
/**
 * 
 * @export
 * @interface PoamResponseDelete
 */
export interface PoamResponseDelete {
    /**
     * 
     * @type {Response200}
     * @memberof PoamResponseDelete
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<PoamPostPutDel>}
     * @memberof PoamResponseDelete
     */
    'data'?: Array<PoamPostPutDel>;
}
/**
 * 
 * @export
 * @interface PoamResponseGetPoams
 */
export interface PoamResponseGetPoams {
    /**
     * 
     * @type {Response200}
     * @memberof PoamResponseGetPoams
     */
    'meta'?: Response200;
    /**
     * 
     * @type {PoamGet}
     * @memberof PoamResponseGetPoams
     */
    'data'?: PoamGet;
}
/**
 * 
 * @export
 * @interface PoamResponseGetSystems
 */
export interface PoamResponseGetSystems {
    /**
     * 
     * @type {Response200}
     * @memberof PoamResponseGetSystems
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<PoamGet>}
     * @memberof PoamResponseGetSystems
     */
    'data'?: Array<PoamGet>;
}
/**
 * 
 * @export
 * @interface PoamResponsePost
 */
export interface PoamResponsePost {
    /**
     * 
     * @type {Response200}
     * @memberof PoamResponsePost
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<PoamPostPutDel>}
     * @memberof PoamResponsePost
     */
    'data'?: Array<PoamPostPutDel>;
}
/**
 * 
 * @export
 * @interface PoamResponsePut
 */
export interface PoamResponsePut {
    /**
     * 
     * @type {Response200}
     * @memberof PoamResponsePut
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<PoamPostPutDel>}
     * @memberof PoamResponsePut
     */
    'data'?: Array<PoamPostPutDel>;
}
/**
 * 
 * @export
 * @interface Register
 */
export interface Register {
    /**
     * 
     * @type {Response200}
     * @memberof Register
     */
    'meta'?: Response200;
    /**
     * 
     * @type {RegisterData}
     * @memberof Register
     */
    'data'?: RegisterData;
}
/**
 * 
 * @export
 * @interface RegisterData
 */
export interface RegisterData {
    /**
     * 
     * @type {string}
     * @memberof RegisterData
     */
    'apikey'?: string;
}
/**
 * 
 * @export
 * @interface RegisterUserRequestPostBody
 */
export interface RegisterUserRequestPostBody {
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequestPostBody
     */
    'user-uid': string;
}
/**
 * 
 * @export
 * @interface Response200
 */
export interface Response200 {
    /**
     * 
     * @type {number}
     * @memberof Response200
     */
    'code'?: number;
}
/**
 * 
 * @export
 * @interface Response201
 */
export interface Response201 {
    /**
     * 
     * @type {Response201Meta}
     * @memberof Response201
     */
    'meta'?: Response201Meta;
}
/**
 * 
 * @export
 * @interface Response201Meta
 */
export interface Response201Meta {
    /**
     * 
     * @type {number}
     * @memberof Response201Meta
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof Response201Meta
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Response400
 */
export interface Response400 {
    /**
     * 
     * @type {Response400Meta}
     * @memberof Response400
     */
    'meta'?: Response400Meta;
}
/**
 * 
 * @export
 * @interface Response400Meta
 */
export interface Response400Meta {
    /**
     * 
     * @type {number}
     * @memberof Response400Meta
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof Response400Meta
     */
    'errorMessage'?: string;
}
/**
 * 
 * @export
 * @interface Response401
 */
export interface Response401 {
    /**
     * 
     * @type {Response401Meta}
     * @memberof Response401
     */
    'meta'?: Response401Meta;
}
/**
 * 
 * @export
 * @interface Response401Meta
 */
export interface Response401Meta {
    /**
     * 
     * @type {number}
     * @memberof Response401Meta
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof Response401Meta
     */
    'errorMessage'?: string;
}
/**
 * 
 * @export
 * @interface Response403
 */
export interface Response403 {
    /**
     * 
     * @type {Response403Meta}
     * @memberof Response403
     */
    'meta'?: Response403Meta;
}
/**
 * 
 * @export
 * @interface Response403Meta
 */
export interface Response403Meta {
    /**
     * 
     * @type {number}
     * @memberof Response403Meta
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof Response403Meta
     */
    'errorMessage'?: string;
}
/**
 * 
 * @export
 * @interface Response404
 */
export interface Response404 {
    /**
     * 
     * @type {number}
     * @memberof Response404
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof Response404
     */
    'errorMessage'?: string;
}
/**
 * 
 * @export
 * @interface Response405
 */
export interface Response405 {
    /**
     * 
     * @type {Response405Meta}
     * @memberof Response405
     */
    'meta'?: Response405Meta;
}
/**
 * 
 * @export
 * @interface Response405Meta
 */
export interface Response405Meta {
    /**
     * 
     * @type {number}
     * @memberof Response405Meta
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof Response405Meta
     */
    'errorMessage'?: string;
}
/**
 * 
 * @export
 * @interface Response411
 */
export interface Response411 {
    /**
     * 
     * @type {Response411Meta}
     * @memberof Response411
     */
    'meta'?: Response411Meta;
}
/**
 * 
 * @export
 * @interface Response411Meta
 */
export interface Response411Meta {
    /**
     * 
     * @type {number}
     * @memberof Response411Meta
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof Response411Meta
     */
    'errorMessage'?: string;
}
/**
 * 
 * @export
 * @interface Response490
 */
export interface Response490 {
    /**
     * 
     * @type {Response490Meta}
     * @memberof Response490
     */
    'meta'?: Response490Meta;
}
/**
 * 
 * @export
 * @interface Response490Meta
 */
export interface Response490Meta {
    /**
     * 
     * @type {number}
     * @memberof Response490Meta
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof Response490Meta
     */
    'errorMessage'?: string;
}
/**
 * 
 * @export
 * @interface Response500
 */
export interface Response500 {
    /**
     * 
     * @type {Response500Meta}
     * @memberof Response500
     */
    'meta'?: Response500Meta;
}
/**
 * 
 * @export
 * @interface Response500Meta
 */
export interface Response500Meta {
    /**
     * 
     * @type {number}
     * @memberof Response500Meta
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof Response500Meta
     */
    'errorMessage'?: string;
}
/**
 * 
 * @export
 * @interface RoleCategory
 */
export interface RoleCategory {
    /**
     * [Read-only] Unique system record identifier.
     * @type {number}
     * @memberof RoleCategory
     */
    'systemId'?: number;
    /**
     * [Read-only] Name of the system record.
     * @type {string}
     * @memberof RoleCategory
     */
    'systemName'?: string | null;
    /**
     * [Read-only] Acronym of the system record.
     * @type {string}
     * @memberof RoleCategory
     */
    'systemAcronym'?: string | null;
    /**
     * 
     * @type {Array<Roles>}
     * @memberof RoleCategory
     */
    'roles'?: Array<Roles> | null;
}
/**
 * 
 * @export
 * @interface Roles
 */
export interface Roles {
    /**
     * [Required] System role categories
     * @type {string}
     * @memberof Roles
     */
    'roleCategory'?: string;
    /**
     * [Required] System role description
     * @type {string}
     * @memberof Roles
     */
    'role'?: string;
    /**
     * 
     * @type {Array<Users>}
     * @memberof Roles
     */
    'users'?: Array<Users> | null;
}
/**
 * 
 * @export
 * @interface Ssps
 */
export interface Ssps {
    /**
     * [Read-Only] Name of the System Security Plan.
     * @type {string}
     * @memberof Ssps
     */
    'sspName'?: string | null;
    /**
     * [Read-Only] Version of the System Security Plan.
     * @type {string}
     * @memberof Ssps
     */
    'sspVersion'?: string | null;
    /**
     * [Read-Only] Date of the System Security Plan. Unix date format.
     * @type {number}
     * @memberof Ssps
     */
    'sspDate'?: number | null;
}
/**
 * 
 * @export
 * @interface Stage
 */
export interface Stage {
    /**
     * [Read-Only] Name of the stage. For older workflows, this will match the user assigned to the stage.
     * @type {string}
     * @memberof Stage
     */
    'name'?: string | null;
    /**
     * 
     * @type {Array<DefinitionTransitions>}
     * @memberof Stage
     */
    'transitions'?: Array<DefinitionTransitions> | null;
}
/**
 * 
 * @export
 * @interface StaticCodeApplication
 */
export interface StaticCodeApplication {
    /**
     * [Optional] Scan vulnerability ratting
     * @type {string}
     * @memberof StaticCodeApplication
     */
    'rawSeverity'?: StaticCodeApplicationRawSeverityEnum;
    /**
     * [Required] Name of the software vulnerability or weakness.
     * @type {string}
     * @memberof StaticCodeApplication
     */
    'codeCheckName'?: string;
    /**
     * [Required] Number of instances observed for a specified finding.
     * @type {number}
     * @memberof StaticCodeApplication
     */
    'count'?: number;
    /**
     * [Required] The date of the scan. Unix date format.
     * @type {number}
     * @memberof StaticCodeApplication
     */
    'scanDate'?: number;
    /**
     * [Required] The Common Weakness Enumerator (CWE) identifier.
     * @type {string}
     * @memberof StaticCodeApplication
     */
    'cweId'?: string;
    /**
     * [Optional] When used by itself, can clear out all application findings for a single application/version pairing.
     * @type {boolean}
     * @memberof StaticCodeApplication
     */
    'clearFindings'?: boolean;
}

export const StaticCodeApplicationRawSeverityEnum = {
    Low: 'Low',
    Medium: 'Medium',
    Moderate: 'Moderate',
    High: 'High',
    Critical: 'Critical',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type StaticCodeApplicationRawSeverityEnum = typeof StaticCodeApplicationRawSeverityEnum[keyof typeof StaticCodeApplicationRawSeverityEnum];

/**
 * 
 * @export
 * @interface StaticCodePost
 */
export interface StaticCodePost {
    /**
     * [Required] Name of the software application that was assessed.
     * @type {string}
     * @memberof StaticCodePost
     */
    'applicationName'?: string;
    /**
     * [Required] The version of the application.
     * @type {string}
     * @memberof StaticCodePost
     */
    'version'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StaticCodePost
     */
    'success'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StaticCodePost
     */
    'systemId'?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof StaticCodePost
     */
    'errors'?: Array<any> | null;
}
/**
 * 
 * @export
 * @interface StaticCodeRequestPostBody
 */
export interface StaticCodeRequestPostBody {
    /**
     * 
     * @type {StaticCodeRequestPostBodyApplication}
     * @memberof StaticCodeRequestPostBody
     */
    'application'?: StaticCodeRequestPostBodyApplication;
    /**
     * 
     * @type {Array<StaticCodeApplication>}
     * @memberof StaticCodeRequestPostBody
     */
    'applicationFindings'?: Array<StaticCodeApplication>;
}
/**
 * 
 * @export
 * @interface StaticCodeRequestPostBodyApplication
 */
export interface StaticCodeRequestPostBodyApplication {
    /**
     * [Required] Name of the software application that was assessed.
     * @type {string}
     * @memberof StaticCodeRequestPostBodyApplication
     */
    'applicationName'?: string;
    /**
     * [Required] The version of the application.
     * @type {string}
     * @memberof StaticCodeRequestPostBodyApplication
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface StaticCodeResponsePost
 */
export interface StaticCodeResponsePost {
    /**
     * 
     * @type {Response200}
     * @memberof StaticCodeResponsePost
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<StaticCodePost>}
     * @memberof StaticCodeResponsePost
     */
    'data'?: Array<StaticCodePost>;
}
/**
 * 
 * @export
 * @interface Success200Response
 */
export interface Success200Response {
    /**
     * 
     * @type {Response200}
     * @memberof Success200Response
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<Success200ResponseDataInner>}
     * @memberof Success200Response
     */
    'data'?: Array<Success200ResponseDataInner>;
}
/**
 * 
 * @export
 * @interface Success200ResponseDataInner
 */
export interface Success200ResponseDataInner {
    /**
     * 
     * @type {boolean}
     * @memberof Success200ResponseDataInner
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof Success200ResponseDataInner
     */
    'errors'?: Array<any> | null;
}
/**
 * 
 * @export
 * @interface SystemResponse
 */
export interface SystemResponse {
    /**
     * 
     * @type {Response200}
     * @memberof SystemResponse
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Systems}
     * @memberof SystemResponse
     */
    'data'?: Systems;
}
/**
 * 
 * @export
 * @interface SystemRolesCategoryResponse
 */
export interface SystemRolesCategoryResponse {
    /**
     * 
     * @type {Response200}
     * @memberof SystemRolesCategoryResponse
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<RoleCategory>}
     * @memberof SystemRolesCategoryResponse
     */
    'data'?: Array<RoleCategory> | null;
}
/**
 * 
 * @export
 * @interface SystemRolesResponse
 */
export interface SystemRolesResponse {
    /**
     * 
     * @type {Response200}
     * @memberof SystemRolesResponse
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<SystemRolesResponseDataInner>}
     * @memberof SystemRolesResponse
     */
    'data'?: Array<SystemRolesResponseDataInner>;
}
/**
 * 
 * @export
 * @interface SystemRolesResponseDataInner
 */
export interface SystemRolesResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof SystemRolesResponseDataInner
     */
    'roleCategory'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemRolesResponseDataInner
     */
    'role'?: string;
}
/**
 * 
 * @export
 * @interface Systems
 */
export interface Systems {
    /**
     * [Read-only] Unique system record identifier.
     * @type {number}
     * @memberof Systems
     */
    'systemId'?: number;
    /**
     * [Read-only] RMF/DIACAP Policy identifier for the system record.
     * @type {string}
     * @memberof Systems
     */
    'policy'?: SystemsPolicyEnum;
    /**
     * [Read-Only] Registration types parameters (assessAndAuthorize, assessOnly, guest, regular, functional, cloudServiceProvider.)
     * @type {string}
     * @memberof Systems
     */
    'registrationType'?: SystemsRegistrationTypeEnum;
    /**
     * [Read-only] Name of the system record.
     * @type {string}
     * @memberof Systems
     */
    'name'?: string | null;
    /**
     * [Read-only] Acronym of the system record.
     * @type {string}
     * @memberof Systems
     */
    'acronym'?: string | null;
    /**
     * [Read-only] Description of the system record.
     * @type {string}
     * @memberof Systems
     */
    'description'?: string | null;
    /**
     * [Read-only] Owning organization of the system record.
     * @type {string}
     * @memberof Systems
     */
    'systemOwner'?: string | null;
    /**
     * [Read-only] Name of the top-level component that owns the system (e.g. Navy, Air Force, Army, etc..).
     * @type {string}
     * @memberof Systems
     */
    'organizationName'?: string | null;
    /**
     * [Read-only] Secondary organization that owns the system record (i.e. Sub-Organization-level.
     * @type {string}
     * @memberof Systems
     */
    'secondaryOrganization'?: string | null;
    /**
     * [Read-only] Version/Release Number of system record.
     * @type {string}
     * @memberof Systems
     */
    'versionReleaseNo'?: string | null;
    /**
     * [Read-only] Type of the system record. RMF values include the following options (IS Major Application, IS Enclave, Platform IT System). DIACAP values include the following options (Platform IT, Interconnection, AIS Application)
     * @type {string}
     * @memberof Systems
     */
    'systemType'?: SystemsSystemTypeEnum;
    /**
     * [Read-only] Is the system record a National Security System?
     * @type {boolean}
     * @memberof Systems
     */
    'isNSS'?: boolean | null;
    /**
     * [Read-only] Does the system record have a public facing component/presence.
     * @type {boolean}
     * @memberof Systems
     */
    'isPublicFacing'?: boolean | null;
    /**
     * [Read-only] Corresponding Cyber Operational Attributes Management System (COAMS) identifier for the system record.
     * @type {number}
     * @memberof Systems
     */
    'coamsId'?: number | null;
    /**
     * [Read-only] Identifies if system is a Type Authorization.
     * @type {boolean}
     * @memberof Systems
     */
    'isTypeAuthorization'?: boolean | null;
    /**
     * [Read-only] DITPR ID of the system record.
     * @type {string}
     * @memberof Systems
     */
    'ditprId'?: string;
    /**
     * [Read-only] Authorization Status of the system record.
     * @type {string}
     * @memberof Systems
     */
    'authorizationStatus'?: SystemsAuthorizationStatusEnum;
    /**
     * [Read-only] Authorization Date of the system record.
     * @type {number}
     * @memberof Systems
     */
    'authorizationDate'?: number | null;
    /**
     * [Read-only] Authorization Termination Date of the system record.
     * @type {number}
     * @memberof Systems
     */
    'authorizationTerminationDate'?: number | null;
    /**
     * [Read-only] Length of system\'s Authorization. Calculated based off of Authorization Date & Authorization Termination Date.
     * @type {number}
     * @memberof Systems
     */
    'authorizationLength'?: number | null;
    /**
     * [Read-only] Terms/Conditions for receiving and maintaining the system\'s Authorization. Assigned by the Authorizing Official.
     * @type {string}
     * @memberof Systems
     */
    'termsForAuth'?: string | null;
    /**
     * [Read-only] Status of the approval of the system\'s RMF Security Plan. Values include the following options (Approved, Denied, Not Yet Approved).
     * @type {string}
     * @memberof Systems
     */
    'securityPlanApprovalStatus'?: SystemsSecurityPlanApprovalStatusEnum;
    /**
     * [Read-only] Approval date of the system\'s RMF Security Plan.
     * @type {number}
     * @memberof Systems
     */
    'securityPlanApprovalDate'?: number | null;
    /**
     * [Read-only] Mission Criticality of the system record. Values include the following options (Mission Critical (MC), Mission Essential (ME), Mission Support (MS).
     * @type {string}
     * @memberof Systems
     */
    'missionCriticality'?: SystemsMissionCriticalityEnum;
    /**
     * [Read-only] Geographical Association of the system record (VA only).
     * @type {string}
     * @memberof Systems
     */
    'geographicalAssociation'?: SystemsGeographicalAssociationEnum;
    /**
     * [Read-only] Ownership of the system record (VA only).
     * @type {string}
     * @memberof Systems
     */
    'systemOwnership'?: string | null;
    /**
     * [Read-only] Governing Mission Area of the system record.
     * @type {string}
     * @memberof Systems
     */
    'governingMissionArea'?: SystemsGoverningMissionAreaEnum;
    /**
     * [Read-only] Primary functional area of the system record.
     * @type {string}
     * @memberof Systems
     */
    'primaryFunctionalArea'?: string | null;
    /**
     * [Read-only] Secondary functional area of the system record.
     * @type {string}
     * @memberof Systems
     */
    'secondaryFunctionalArea'?: string | null;
    /**
     * [Read-only] Primary Control Set of the system record. RMF values include the following options (NIST SP 800-53 Revision 4), DIACAP values include the following options (DoDI 8500.2)
     * @type {string}
     * @memberof Systems
     */
    'primaryControlSet'?: SystemsPrimaryControlSetEnum;
    /**
     * [Read-only] Confidentiality of the system record. RMF values include the following options (High, Moderate, Low)
     * @type {string}
     * @memberof Systems
     */
    'confidentiality'?: SystemsConfidentialityEnum;
    /**
     * [Read-only] Integrity of the system record. RMF values include the following options (High, Moderate, Low)
     * @type {string}
     * @memberof Systems
     */
    'integrity'?: SystemsIntegrityEnum;
    /**
     * [Read-only] Availability of the system record. RMF values include the following options (High, Moderate, Low)
     * @type {string}
     * @memberof Systems
     */
    'availability'?: SystemsAvailabilityEnum;
    /**
     * [Read-only] Overlays applied to the system record.
     * @type {string}
     * @memberof Systems
     */
    'appliedOverlays'?: string | null;
    /**
     * [Read-only] RMF Activity of the system record.
     * @type {string}
     * @memberof Systems
     */
    'rmfActivity'?: string | null;
    /**
     * [Read-only] Cross Domain Tickets of the system record.
     * @type {string}
     * @memberof Systems
     */
    'crossDomainTicket'?: string | null;
    /**
     * [Read-Only] DITPR-DON identifier of the system record.
     * @type {string}
     * @memberof Systems
     */
    'ditprDonId'?: string | null;
    /**
     * [Read-Only] MAC level of the system record.
     * @type {string}
     * @memberof Systems
     */
    'mac'?: SystemsMacEnum;
    /**
     * [Read-Only] DoD Confidentiality level of the system record.
     * @type {string}
     * @memberof Systems
     */
    'dodConfidentiality'?: SystemsDodConfidentialityEnum;
    /**
     * [Read-only] Has the system record\'s Contingency Plan been tested?
     * @type {boolean}
     * @memberof Systems
     */
    'contingencyPlanTested'?: boolean | null;
    /**
     * [Read-only] Date the system record\'s Contingency Plan was tested.
     * @type {number}
     * @memberof Systems
     */
    'contingencyPlanTestDate'?: number | null;
    /**
     * [Read-only] Date the system record\'s Annual Security Review was conducted.
     * @type {number}
     * @memberof Systems
     */
    'securityReviewDate'?: number | null;
    /**
     * [Read-Only] Does the system record have an Ongoing or Risk Accepted POA&M Item?
     * @type {boolean}
     * @memberof Systems
     */
    'hasOpenPoamItem'?: boolean | null;
    /**
     * [Read-Only] Does the system record have an Ongoing or Risk Accepted POA&M Item 90 to 120 days past its Scheduled Completion Date?
     * @type {boolean}
     * @memberof Systems
     */
    'hasOpenPoamItem90to120PastScheduledCompletionDate'?: boolean | null;
    /**
     * [Read-Only] Does the system record have an Ongoing or Risk Accepted POA&M Item 120 days past its Scheduled Completion Date?
     * @type {boolean}
     * @memberof Systems
     */
    'hasOpenPoamItem120PlusPastScheudledCompletionDate'?: boolean | null;
    /**
     * [Optional] Values include the following options (Very Low, Low, Moderate,High,Very High)
     * @type {string}
     * @memberof Systems
     */
    'impact'?: SystemsImpactEnum;
    /**
     * [Read-only] Does the system record contain and/or process Controlled Unclassified information?
     * @type {boolean}
     * @memberof Systems
     */
    'hasCUI'?: boolean | null;
    /**
     * [Read-only] Does the system record contain and/or process Personally Identifiable Information?
     * @type {boolean}
     * @memberof Systems
     */
    'hasPII'?: boolean | null;
    /**
     * [Read-only] Does the system record contain and/or process Personal Health Information?
     * @type {boolean}
     * @memberof Systems
     */
    'hasPHI'?: boolean | null;
    /**
     * [Read-only] Unique identifier for the DoD’s Ports, Protocols, and Services Management Registry system.
     * @type {string}
     * @memberof Systems
     */
    'ppsmRegistryNumber'?: string | null;
    /**
     * [Read-only] Identify the interconnected information systems and corresponding identifiers within control CA-3.
     * @type {string}
     * @memberof Systems
     */
    'interconnectedInformationSystemAndIdentifiers'?: string | null;
    /**
     * [Read-only] Does the system require a Privacy Impact Assessment?
     * @type {boolean}
     * @memberof Systems
     */
    'isPiaRequired'?: boolean | null;
    /**
     * [Read-only] Status of the PIA, availability values include the following options (Not Started, In Progress, Completed)
     * @type {string}
     * @memberof Systems
     */
    'piaStatus'?: SystemsPiaStatusEnum;
    /**
     * [Read-only] Date in which the system\'s PIA took place.
     * @type {number}
     * @memberof Systems
     */
    'piaDate'?: number | null;
    /**
     * [Read-only] User-defined field to augment Ad Hoc Reporting.
     * @type {string}
     * @memberof Systems
     */
    'userDefinedField1'?: string | null;
    /**
     * [Read-only] User-defined field to augment Ad Hoc Reporting.
     * @type {string}
     * @memberof Systems
     */
    'userDefinedField2'?: string | null;
    /**
     * [Read-only] User-defined field to augment Ad Hoc Reporting.
     * @type {string}
     * @memberof Systems
     */
    'userDefinedField3'?: string | null;
    /**
     * [Read-only] User-defined field to augment Ad Hoc Reporting.
     * @type {string}
     * @memberof Systems
     */
    'userDefinedField4'?: string | null;
    /**
     * [Read-only] User-defined field to augment Ad Hoc Reporting.
     * @type {string}
     * @memberof Systems
     */
    'userDefinedField5'?: string | null;
    /**
     * [Read-only] Displays the system\'s current step within the RMF Lifecycle.
     * @type {string}
     * @memberof Systems
     */
    'currentRmfLifecycleStep'?: SystemsCurrentRmfLifecycleStepEnum;
    /**
     * [Read-only] Include any additional information required by the organization.
     * @type {string}
     * @memberof Systems
     */
    'otherInformation'?: string | null;
    /**
     * [Read-only] Indicates if the system reports to the DoD Cyber Hygiene Scorecard.
     * @type {boolean}
     * @memberof Systems
     */
    'reportsForScorecard'?: boolean | null;
    /**
     * 
     * @type {Array<PacGet>}
     * @memberof Systems
     */
    'package'?: Array<PacGet> | null;
    /**
     * 
     * @type {Array<ConnectivityCcsd>}
     * @memberof Systems
     */
    'connectivityCcsd'?: Array<ConnectivityCcsd> | null;
}

export const SystemsPolicyEnum = {
    Rmf: 'RMF',
    Diacap: 'DIACAP',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type SystemsPolicyEnum = typeof SystemsPolicyEnum[keyof typeof SystemsPolicyEnum];
export const SystemsRegistrationTypeEnum = {
    AssessAndAuthorize: 'Assess and Authorize',
    AssessOnly: 'Assess Only',
    Guest: 'Guest',
    Regular: 'Regular',
    Functional: 'Functional',
    CloudServiceProvider: 'Cloud Service Provider',
    CommonControlProvider: 'Common Control Provider',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type SystemsRegistrationTypeEnum = typeof SystemsRegistrationTypeEnum[keyof typeof SystemsRegistrationTypeEnum];
export const SystemsSystemTypeEnum = {
    IsMajorApplication: 'IS Major Application',
    IsEnclave: 'IS Enclave',
    PlatformIt: 'Platform IT',
    PlatformItSystem: 'Platform IT System',
    PlatformItInterconnection: 'Platform IT Interconnection',
    AisApplication: 'AIS Application',
    OutsourcedItBasedProcessDoDControlled: 'Outsourced IT-Based Process (DoD-controlled)',
    Enclave: 'Enclave',
    OutsourcedItBasedProcessServiceProviderShared: 'Outsourced IT-Based Process (service provider shared)',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type SystemsSystemTypeEnum = typeof SystemsSystemTypeEnum[keyof typeof SystemsSystemTypeEnum];
export const SystemsAuthorizationStatusEnum = {
    AuthorityToOperateAto: 'Authority to Operate (ATO)',
    AuthorizationToOperateAto: 'Authorization to Operate (ATO)',
    AuthorityToOperateWithConditionsAtoWConditions: 'Authority to Operate with Conditions (ATO w/Conditions)',
    InterimAuthorityToTestIatt: 'Interim Authority to Test (IATT)',
    InterimAuthorityToOperateIato: 'Interim Authority to Operate (IATO)',
    DeniedAuthorityToOperateDato: 'Denied Authority to Operate (DATO)',
    DenialOfAuthorizationToOperateDato: 'Denial of Authorization to Operate (DATO)',
    NotYetAuthorized: 'Not Yet Authorized',
    Decommissioned: 'Decommissioned',
    Unaccredited: 'Unaccredited',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type SystemsAuthorizationStatusEnum = typeof SystemsAuthorizationStatusEnum[keyof typeof SystemsAuthorizationStatusEnum];
export const SystemsSecurityPlanApprovalStatusEnum = {
    Approved: 'Approved',
    NotYetApproved: 'Not Yet Approved',
    Denied: 'Denied',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type SystemsSecurityPlanApprovalStatusEnum = typeof SystemsSecurityPlanApprovalStatusEnum[keyof typeof SystemsSecurityPlanApprovalStatusEnum];
export const SystemsMissionCriticalityEnum = {
    CriticalMc: 'Mission Critical (MC)',
    EssentialMe: 'Mission Essential (ME)',
    SupportMs: 'Mission Support (MS)',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type SystemsMissionCriticalityEnum = typeof SystemsMissionCriticalityEnum[keyof typeof SystemsMissionCriticalityEnum];
export const SystemsGeographicalAssociationEnum = {
    VaOperatedIs: 'VA Operated IS',
    NonVaOperatedIs: 'non-VA Operated IS',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type SystemsGeographicalAssociationEnum = typeof SystemsGeographicalAssociationEnum[keyof typeof SystemsGeographicalAssociationEnum];
export const SystemsGoverningMissionAreaEnum = {
    BusinessMaBma: 'Business MA (BMA)',
    DoDPortionOfTheIntelligenceMaDima: 'DoD portion of the Intelligence MA (DIMA)',
    EnterpriseInformationEnvironmentMaEiema: 'Enterprise Information Environment MA (EIEMA)',
    WarfightingMaWma: 'Warfighting MA (WMA)',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type SystemsGoverningMissionAreaEnum = typeof SystemsGoverningMissionAreaEnum[keyof typeof SystemsGoverningMissionAreaEnum];
export const SystemsPrimaryControlSetEnum = {
    NistSp80053Revision4: 'NIST SP 800-53 Revision 4',
    DoDi85002: 'DoDI 8500.2',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type SystemsPrimaryControlSetEnum = typeof SystemsPrimaryControlSetEnum[keyof typeof SystemsPrimaryControlSetEnum];
export const SystemsConfidentialityEnum = {
    High: 'High',
    Moderate: 'Moderate',
    Low: 'Low',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type SystemsConfidentialityEnum = typeof SystemsConfidentialityEnum[keyof typeof SystemsConfidentialityEnum];
export const SystemsIntegrityEnum = {
    High: 'High',
    Moderate: 'Moderate',
    Low: 'Low',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type SystemsIntegrityEnum = typeof SystemsIntegrityEnum[keyof typeof SystemsIntegrityEnum];
export const SystemsAvailabilityEnum = {
    High: 'High',
    Moderate: 'Moderate',
    Low: 'Low',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type SystemsAvailabilityEnum = typeof SystemsAvailabilityEnum[keyof typeof SystemsAvailabilityEnum];
export const SystemsMacEnum = {
    I: 'I',
    Ii: 'II',
    Iii: 'III',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type SystemsMacEnum = typeof SystemsMacEnum[keyof typeof SystemsMacEnum];
export const SystemsDodConfidentialityEnum = {
    Public: 'Public',
    Sensitive: 'Sensitive',
    Classified: 'Classified',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type SystemsDodConfidentialityEnum = typeof SystemsDodConfidentialityEnum[keyof typeof SystemsDodConfidentialityEnum];
export const SystemsImpactEnum = {
    Low: 'Low',
    Moderate: 'Moderate',
    High: 'High',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type SystemsImpactEnum = typeof SystemsImpactEnum[keyof typeof SystemsImpactEnum];
export const SystemsPiaStatusEnum = {
    NotStarted: 'Not Started',
    InProgress: 'In Progress',
    Completed: 'Completed',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type SystemsPiaStatusEnum = typeof SystemsPiaStatusEnum[keyof typeof SystemsPiaStatusEnum];
export const SystemsCurrentRmfLifecycleStepEnum = {
    _1Categorize: '1 - Categorize',
    _2Select: '2 - Select',
    _3Implement: '3 - Implement',
    _4Assess: '4 - Assess',
    _5Authorize: '5 - Authorize',
    _6Monitor: '6 - Monitor',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type SystemsCurrentRmfLifecycleStepEnum = typeof SystemsCurrentRmfLifecycleStepEnum[keyof typeof SystemsCurrentRmfLifecycleStepEnum];

/**
 * 
 * @export
 * @interface SystemsResponse
 */
export interface SystemsResponse {
    /**
     * 
     * @type {Response200}
     * @memberof SystemsResponse
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<Systems>}
     * @memberof SystemsResponse
     */
    'data'?: Array<Systems>;
}
/**
 * 
 * @export
 * @interface Test
 */
export interface Test {
    /**
     * 
     * @type {Response200}
     * @memberof Test
     */
    'meta'?: Response200;
    /**
     * 
     * @type {TestData}
     * @memberof Test
     */
    'data'?: TestData;
}
/**
 * 
 * @export
 * @interface TestData
 */
export interface TestData {
    /**
     * 
     * @type {boolean}
     * @memberof TestData
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface TestResultsGet
 */
export interface TestResultsGet {
    /**
     * [Required] Unique eMASS identifier. Will need to provide correct number
     * @type {number}
     * @memberof TestResultsGet
     */
    'systemId'?: number;
    /**
     * [Read-Only] Control acronym associated with the test result. NIST SP 800-53 Revision 4 defined.
     * @type {string}
     * @memberof TestResultsGet
     */
    'control'?: string | null;
    /**
     * [Required] CCI associated with test result.
     * @type {string}
     * @memberof TestResultsGet
     */
    'cci'?: string;
    /**
     * [Read-only] Indicates whether a test result is inherited.
     * @type {boolean}
     * @memberof TestResultsGet
     */
    'isInherited'?: boolean | null;
    /**
     * [Required] Last Name, First Name. 100 Characters.
     * @type {string}
     * @memberof TestResultsGet
     */
    'testedBy'?: string;
    /**
     * [Required] Unix time format.
     * @type {number}
     * @memberof TestResultsGet
     */
    'testDate'?: number;
    /**
     * [Required] Include description of test result. 4000 Characters.
     * @type {string}
     * @memberof TestResultsGet
     */
    'description'?: string;
    /**
     * [Read-Only] Indicates the location in the Control Approval Chain when the test result is submitted.
     * @type {string}
     * @memberof TestResultsGet
     */
    'type'?: string | null;
    /**
     * [Required] Test result compliance status
     * @type {string}
     * @memberof TestResultsGet
     */
    'complianceStatus'?: TestResultsGetComplianceStatusEnum;
}

export const TestResultsGetComplianceStatusEnum = {
    Compliant: 'Compliant',
    NonCompliant: 'Non-Compliant',
    NotApplicable: 'Not Applicable',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type TestResultsGetComplianceStatusEnum = typeof TestResultsGetComplianceStatusEnum[keyof typeof TestResultsGetComplianceStatusEnum];

/**
 * 
 * @export
 * @interface TestResultsPost
 */
export interface TestResultsPost {
    /**
     * CCI associated with test result.
     * @type {string}
     * @memberof TestResultsPost
     */
    'cci'?: string;
    /**
     * Indicates if operations result (success/fail)
     * @type {boolean}
     * @memberof TestResultsPost
     */
    'success'?: boolean;
    /**
     * The system identifier for the system being updated.
     * @type {number}
     * @memberof TestResultsPost
     */
    'systemId'?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof TestResultsPost
     */
    'errors'?: Array<any> | null;
}
/**
 * 
 * @export
 * @interface TestResultsResponseGet
 */
export interface TestResultsResponseGet {
    /**
     * 
     * @type {Response200}
     * @memberof TestResultsResponseGet
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<TestResultsGet>}
     * @memberof TestResultsResponseGet
     */
    'data'?: Array<TestResultsGet>;
}
/**
 * 
 * @export
 * @interface TestResultsResponsePost
 */
export interface TestResultsResponsePost {
    /**
     * 
     * @type {Response200}
     * @memberof TestResultsResponsePost
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<TestResultsPost>}
     * @memberof TestResultsResponsePost
     */
    'data'?: Array<TestResultsPost>;
}
/**
 * 
 * @export
 * @interface Users
 */
export interface Users {
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface WorkflowDefinitionGet
 */
export interface WorkflowDefinitionGet {
    /**
     * [Read-Only] Unique workflow definition identifier.
     * @type {string}
     * @memberof WorkflowDefinitionGet
     */
    'workflowUid'?: string | null;
    /**
     * [Read-Only] The workflow type.
     * @type {string}
     * @memberof WorkflowDefinitionGet
     */
    'workflow'?: string | null;
    /**
     * [Read-Only] Version of the workflow definition.
     * @type {string}
     * @memberof WorkflowDefinitionGet
     */
    'version'?: string | null;
    /**
     * [Read-Only] Description of the workflow or the stage transition.
     * @type {string}
     * @memberof WorkflowDefinitionGet
     */
    'description'?: string | null;
    /**
     * [Read-Only] Returns true if the workflow is available to the site.
     * @type {boolean}
     * @memberof WorkflowDefinitionGet
     */
    'isActive'?: boolean | null;
    /**
     * 
     * @type {Array<Stage>}
     * @memberof WorkflowDefinitionGet
     */
    'stages'?: Array<Stage> | null;
}
/**
 * 
 * @export
 * @interface WorkflowDefinitionResponseGet
 */
export interface WorkflowDefinitionResponseGet {
    /**
     * 
     * @type {Response200}
     * @memberof WorkflowDefinitionResponseGet
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<WorkflowDefinitionGet>}
     * @memberof WorkflowDefinitionResponseGet
     */
    'data'?: Array<WorkflowDefinitionGet>;
}
/**
 * 
 * @export
 * @interface WorkflowInstanceGet
 */
export interface WorkflowInstanceGet {
    /**
     * [Read-Only] Unique workflow definition identifier.
     * @type {string}
     * @memberof WorkflowInstanceGet
     */
    'workflowUid'?: string | null;
    /**
     * [Read-Only] The system name.
     * @type {string}
     * @memberof WorkflowInstanceGet
     */
    'systemName'?: string | null;
    /**
     * [Read-Only] Unique workflow instance identifier.
     * @type {number}
     * @memberof WorkflowInstanceGet
     */
    'workflowInstanceId'?: number | null;
    /**
     * [Read-Only] The package name.
     * @type {string}
     * @memberof WorkflowInstanceGet
     */
    'packageName'?: string | null;
    /**
     * [Read-Only] Date the workflow instance or the workflow transition was created.
     * @type {number}
     * @memberof WorkflowInstanceGet
     */
    'createdDate'?: number | null;
    /**
     * [Read-Only] Date the workflow was last acted on.
     * @type {number}
     * @memberof WorkflowInstanceGet
     */
    'lastEditedDate'?: number | null;
    /**
     * [Read-Only] User that last acted on the workflow.
     * @type {string}
     * @memberof WorkflowInstanceGet
     */
    'lastEditedBy'?: string | null;
    /**
     * [Read-Only] The workflow type.
     * @type {string}
     * @memberof WorkflowInstanceGet
     */
    'workflow'?: string | null;
    /**
     * [Read-Only] Version of the workflow definition.
     * @type {string}
     * @memberof WorkflowInstanceGet
     */
    'version'?: string | null;
    /**
     * [Read-Only] Name of the current stage.
     * @type {string}
     * @memberof WorkflowInstanceGet
     */
    'currentStage'?: string | null;
    /**
     * 
     * @type {Array<InstancesTransitions>}
     * @memberof WorkflowInstanceGet
     */
    'transitions'?: Array<InstancesTransitions>;
}
/**
 * 
 * @export
 * @interface WorkflowInstanceResponseGet
 */
export interface WorkflowInstanceResponseGet {
    /**
     * 
     * @type {Response200}
     * @memberof WorkflowInstanceResponseGet
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<WorkflowInstanceGet>}
     * @memberof WorkflowInstanceResponseGet
     */
    'data'?: Array<WorkflowInstanceGet>;
}
/**
 * 
 * @export
 * @interface WorkflowInstancesGet
 */
export interface WorkflowInstancesGet {
    /**
     * [Read-Only] Unique workflow definition identifier.
     * @type {string}
     * @memberof WorkflowInstancesGet
     */
    'workflowUid'?: string | null;
    /**
     * [Read-only] Unique system record identifier.
     * @type {number}
     * @memberof WorkflowInstancesGet
     */
    'systemId'?: number | null;
    /**
     * [Read-Only] The system name.
     * @type {string}
     * @memberof WorkflowInstancesGet
     */
    'systemName'?: string | null;
    /**
     * [Read-Only] Unique workflow instance identifier.
     * @type {number}
     * @memberof WorkflowInstancesGet
     */
    'workflowInstanceId'?: number | null;
    /**
     * [Read-Only] The package name.
     * @type {string}
     * @memberof WorkflowInstancesGet
     */
    'packageName'?: string | null;
    /**
     * [Read-Only] Date the workflow instance or the workflow transition was created.
     * @type {number}
     * @memberof WorkflowInstancesGet
     */
    'createdDate'?: number | null;
    /**
     * [Read-Only] Date the workflow was last acted on.
     * @type {number}
     * @memberof WorkflowInstancesGet
     */
    'lastEditedDate'?: number | null;
    /**
     * [Read-Only] User that last acted on the workflow.
     * @type {string}
     * @memberof WorkflowInstancesGet
     */
    'lastEditedBy'?: string | null;
    /**
     * [Read-Only] The workflow type.
     * @type {string}
     * @memberof WorkflowInstancesGet
     */
    'workflow'?: string | null;
    /**
     * [Read-Only] Version of the workflow definition.
     * @type {string}
     * @memberof WorkflowInstancesGet
     */
    'version'?: string | null;
    /**
     * [Read-Only] Name of the current stage.
     * @type {string}
     * @memberof WorkflowInstancesGet
     */
    'currentStage'?: string | null;
    /**
     * 
     * @type {Array<InstancesTransitions>}
     * @memberof WorkflowInstancesGet
     */
    'transitions'?: Array<InstancesTransitions>;
}
/**
 * 
 * @export
 * @interface WorkflowInstancesResponseGet
 */
export interface WorkflowInstancesResponseGet {
    /**
     * 
     * @type {Response200}
     * @memberof WorkflowInstancesResponseGet
     */
    'meta'?: Response200;
    /**
     * 
     * @type {Array<WorkflowInstancesGet>}
     * @memberof WorkflowInstancesResponseGet
     */
    'data'?: Array<WorkflowInstancesGet>;
    /**
     * 
     * @type {WorkflowInstancesResponseGetPagination}
     * @memberof WorkflowInstancesResponseGet
     */
    'pagination'?: WorkflowInstancesResponseGetPagination;
}
/**
 * 
 * @export
 * @interface WorkflowInstancesResponseGetPagination
 */
export interface WorkflowInstancesResponseGetPagination {
    /**
     * 
     * @type {number}
     * @memberof WorkflowInstancesResponseGetPagination
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowInstancesResponseGetPagination
     */
    'totalPages'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowInstancesResponseGetPagination
     */
    'prevPageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowInstancesResponseGetPagination
     */
    'nextPageUrl'?: string;
}

/**
 * ArtifactsApi - axios parameter creator
 * @export
 */
export const ArtifactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <strong>Information</strong><br> The request body of a POST request through the Artifact Endpoint accepts a single binary file with file extension \".zip\" only. This accepted .zip file should contain one or more files corresponding to existing artifacts or new artifacts that will be created upon successful receipt. Filename uniqueness throughout eMASS will be enforced by the API.<br><br> Upon successful receipt of a file, if a file within the .zip is matched via filename to an artifact existing within the application, the file associated with the artifact will be updated. If no artifact is matched via filename to the application, a new artifact will be created with the following default values. Any values not specified below will be blank. <ul>   <li>isTemplate: false</li>   <li>type: other</li>   <li>category: evidence</li> </ul> To update values other than the file itself, please submit a PUT request.<br>  <strong>Zip file information</strong><br> Upload a zip file contain one or more files corresponding to existing artifacts or new artifacts that will be created upon successful receipt.<br><br> <strong>Business Rules</strong><br> Artifact cannot be saved if the file does not have the following file extensions:      .docx,.doc,.txt,.rtf,.xfdl,.xml,.mht,.mh,tml,.html,.htm,.pdf,.mdb,.accdb,.ppt,     .pptx,.xls,.xlsx,.csv,.log,.jpeg,.jpg,.tiff,.bmp,.tif,.png,.gif,.zip,.rar,.msg,     .vsd,.vsw,.vdx,.z{#},.ckl,.avi,.vsdx  Artifact version cannot be saved if an Artifact with the same file name already exist in the system.  Artifact cannot be saved if the file size exceeds 30MB.
         * @summary Add one or many artifacts in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {any} zipper 
         * @param {boolean} [isTemplate] 
         * @param {string} [type] 
         * @param {string} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addArtifactsBySystemId: async (systemId: number, zipper: any, isTemplate?: boolean, type?: string, category?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('addArtifactsBySystemId', 'systemId', systemId)
            // verify required parameter 'zipper' is not null or undefined
            assertParamExists('addArtifactsBySystemId', 'zipper', zipper)
            const localVarPath = `/api/systems/{systemId}/artifacts`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


            if (isTemplate !== undefined) { 
                localVarFormParams.append('isTemplate', isTemplate as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.append('type', type as any);
            }
    
            if (category !== undefined) { 
                localVarFormParams.append('category', category as any);
            }
    
            if (zipper !== undefined) { 
                localVarFormParams.append('Zipper', zipper as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the Artifact(s) matching `systemId` path parameter and request body artifact(s) file name<br><br> <b>Note:</b> Multiple files can be deleted by providing multiple file names at the CL (comma delimited)  Example: --files file1.txt, file2.txt
         * @summary Remove one or many artifacts in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<DeleteArtifactsInner>} [deleteArtifactsInner] Delete artifact files for the given System Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact: async (systemId: number, deleteArtifactsInner?: Array<DeleteArtifactsInner>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('deleteArtifact', 'systemId', systemId)
            const localVarPath = `/api/systems/{systemId}/artifacts`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteArtifactsInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns selected artifacts matching parameters to include the file name containing the artifacts.
         * @summary Get one or many artifacts in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {string} [filename] **File Name**: The file name (to include file-extension).
         * @param {string} [controlAcronyms] **System Acronym**: Filter query by given system acronym (single or comma separated).
         * @param {string} [ccis] **CCI System**: Filter query by Control Correlation Identifiers (CCIs) (single or comma separated).
         * @param {boolean} [systemOnly] **Systems Only**: Indicates that only system(s) information is retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemArtifacts: async (systemId: number, filename?: string, controlAcronyms?: string, ccis?: string, systemOnly?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('getSystemArtifacts', 'systemId', systemId)
            const localVarPath = `/api/systems/{systemId}/artifacts`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (controlAcronyms !== undefined) {
                localVarQueryParameter['controlAcronyms'] = controlAcronyms;
            }

            if (ccis !== undefined) {
                localVarQueryParameter['ccis'] = ccis;
            }

            if (systemOnly !== undefined) {
                localVarQueryParameter['systemOnly'] = systemOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an artifact for given `systemId` path parameter<br><br>  **Request Body Required Fields** - `filename` - `isTemplate` - `type` - `category`
         * @summary Update one or many artifacts in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody See &#x60;information&#x60; above for additional instructions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactBySystemId: async (systemId: number, requestBody: Array<object>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('updateArtifactBySystemId', 'systemId', systemId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateArtifactBySystemId', 'requestBody', requestBody)
            const localVarPath = `/api/systems/{systemId}/artifacts`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactsApi - functional programming interface
 * @export
 */
export const ArtifactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtifactsApiAxiosParamCreator(configuration)
    return {
        /**
         * <strong>Information</strong><br> The request body of a POST request through the Artifact Endpoint accepts a single binary file with file extension \".zip\" only. This accepted .zip file should contain one or more files corresponding to existing artifacts or new artifacts that will be created upon successful receipt. Filename uniqueness throughout eMASS will be enforced by the API.<br><br> Upon successful receipt of a file, if a file within the .zip is matched via filename to an artifact existing within the application, the file associated with the artifact will be updated. If no artifact is matched via filename to the application, a new artifact will be created with the following default values. Any values not specified below will be blank. <ul>   <li>isTemplate: false</li>   <li>type: other</li>   <li>category: evidence</li> </ul> To update values other than the file itself, please submit a PUT request.<br>  <strong>Zip file information</strong><br> Upload a zip file contain one or more files corresponding to existing artifacts or new artifacts that will be created upon successful receipt.<br><br> <strong>Business Rules</strong><br> Artifact cannot be saved if the file does not have the following file extensions:      .docx,.doc,.txt,.rtf,.xfdl,.xml,.mht,.mh,tml,.html,.htm,.pdf,.mdb,.accdb,.ppt,     .pptx,.xls,.xlsx,.csv,.log,.jpeg,.jpg,.tiff,.bmp,.tif,.png,.gif,.zip,.rar,.msg,     .vsd,.vsw,.vdx,.z{#},.ckl,.avi,.vsdx  Artifact version cannot be saved if an Artifact with the same file name already exist in the system.  Artifact cannot be saved if the file size exceeds 30MB.
         * @summary Add one or many artifacts in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {any} zipper 
         * @param {boolean} [isTemplate] 
         * @param {string} [type] 
         * @param {string} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addArtifactsBySystemId(systemId: number, zipper: any, isTemplate?: boolean, type?: string, category?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactsResponsePutPost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addArtifactsBySystemId(systemId, zipper, isTemplate, type, category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove the Artifact(s) matching `systemId` path parameter and request body artifact(s) file name<br><br> <b>Note:</b> Multiple files can be deleted by providing multiple file names at the CL (comma delimited)  Example: --files file1.txt, file2.txt
         * @summary Remove one or many artifacts in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<DeleteArtifactsInner>} [deleteArtifactsInner] Delete artifact files for the given System Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtifact(systemId: number, deleteArtifactsInner?: Array<DeleteArtifactsInner>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactsResponseDel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtifact(systemId, deleteArtifactsInner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns selected artifacts matching parameters to include the file name containing the artifacts.
         * @summary Get one or many artifacts in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {string} [filename] **File Name**: The file name (to include file-extension).
         * @param {string} [controlAcronyms] **System Acronym**: Filter query by given system acronym (single or comma separated).
         * @param {string} [ccis] **CCI System**: Filter query by Control Correlation Identifiers (CCIs) (single or comma separated).
         * @param {boolean} [systemOnly] **Systems Only**: Indicates that only system(s) information is retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemArtifacts(systemId: number, filename?: string, controlAcronyms?: string, ccis?: string, systemOnly?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactsResponseGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemArtifacts(systemId, filename, controlAcronyms, ccis, systemOnly, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an artifact for given `systemId` path parameter<br><br>  **Request Body Required Fields** - `filename` - `isTemplate` - `type` - `category`
         * @summary Update one or many artifacts in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody See &#x60;information&#x60; above for additional instructions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArtifactBySystemId(systemId: number, requestBody: Array<object>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactsResponsePutPost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArtifactBySystemId(systemId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArtifactsApi - factory interface
 * @export
 */
export const ArtifactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtifactsApiFp(configuration)
    return {
        /**
         * <strong>Information</strong><br> The request body of a POST request through the Artifact Endpoint accepts a single binary file with file extension \".zip\" only. This accepted .zip file should contain one or more files corresponding to existing artifacts or new artifacts that will be created upon successful receipt. Filename uniqueness throughout eMASS will be enforced by the API.<br><br> Upon successful receipt of a file, if a file within the .zip is matched via filename to an artifact existing within the application, the file associated with the artifact will be updated. If no artifact is matched via filename to the application, a new artifact will be created with the following default values. Any values not specified below will be blank. <ul>   <li>isTemplate: false</li>   <li>type: other</li>   <li>category: evidence</li> </ul> To update values other than the file itself, please submit a PUT request.<br>  <strong>Zip file information</strong><br> Upload a zip file contain one or more files corresponding to existing artifacts or new artifacts that will be created upon successful receipt.<br><br> <strong>Business Rules</strong><br> Artifact cannot be saved if the file does not have the following file extensions:      .docx,.doc,.txt,.rtf,.xfdl,.xml,.mht,.mh,tml,.html,.htm,.pdf,.mdb,.accdb,.ppt,     .pptx,.xls,.xlsx,.csv,.log,.jpeg,.jpg,.tiff,.bmp,.tif,.png,.gif,.zip,.rar,.msg,     .vsd,.vsw,.vdx,.z{#},.ckl,.avi,.vsdx  Artifact version cannot be saved if an Artifact with the same file name already exist in the system.  Artifact cannot be saved if the file size exceeds 30MB.
         * @summary Add one or many artifacts in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {any} zipper 
         * @param {boolean} [isTemplate] 
         * @param {string} [type] 
         * @param {string} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addArtifactsBySystemId(systemId: number, zipper: any, isTemplate?: boolean, type?: string, category?: string, options?: any): AxiosPromise<ArtifactsResponsePutPost> {
            return localVarFp.addArtifactsBySystemId(systemId, zipper, isTemplate, type, category, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove the Artifact(s) matching `systemId` path parameter and request body artifact(s) file name<br><br> <b>Note:</b> Multiple files can be deleted by providing multiple file names at the CL (comma delimited)  Example: --files file1.txt, file2.txt
         * @summary Remove one or many artifacts in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<DeleteArtifactsInner>} [deleteArtifactsInner] Delete artifact files for the given System Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact(systemId: number, deleteArtifactsInner?: Array<DeleteArtifactsInner>, options?: any): AxiosPromise<ArtifactsResponseDel> {
            return localVarFp.deleteArtifact(systemId, deleteArtifactsInner, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns selected artifacts matching parameters to include the file name containing the artifacts.
         * @summary Get one or many artifacts in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {string} [filename] **File Name**: The file name (to include file-extension).
         * @param {string} [controlAcronyms] **System Acronym**: Filter query by given system acronym (single or comma separated).
         * @param {string} [ccis] **CCI System**: Filter query by Control Correlation Identifiers (CCIs) (single or comma separated).
         * @param {boolean} [systemOnly] **Systems Only**: Indicates that only system(s) information is retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemArtifacts(systemId: number, filename?: string, controlAcronyms?: string, ccis?: string, systemOnly?: boolean, options?: any): AxiosPromise<ArtifactsResponseGet> {
            return localVarFp.getSystemArtifacts(systemId, filename, controlAcronyms, ccis, systemOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an artifact for given `systemId` path parameter<br><br>  **Request Body Required Fields** - `filename` - `isTemplate` - `type` - `category`
         * @summary Update one or many artifacts in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody See &#x60;information&#x60; above for additional instructions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactBySystemId(systemId: number, requestBody: Array<object>, options?: any): AxiosPromise<ArtifactsResponsePutPost> {
            return localVarFp.updateArtifactBySystemId(systemId, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtifactsApi - object-oriented interface
 * @export
 * @class ArtifactsApi
 * @extends {BaseAPI}
 */
export class ArtifactsApi extends BaseAPI {
    /**
     * <strong>Information</strong><br> The request body of a POST request through the Artifact Endpoint accepts a single binary file with file extension \".zip\" only. This accepted .zip file should contain one or more files corresponding to existing artifacts or new artifacts that will be created upon successful receipt. Filename uniqueness throughout eMASS will be enforced by the API.<br><br> Upon successful receipt of a file, if a file within the .zip is matched via filename to an artifact existing within the application, the file associated with the artifact will be updated. If no artifact is matched via filename to the application, a new artifact will be created with the following default values. Any values not specified below will be blank. <ul>   <li>isTemplate: false</li>   <li>type: other</li>   <li>category: evidence</li> </ul> To update values other than the file itself, please submit a PUT request.<br>  <strong>Zip file information</strong><br> Upload a zip file contain one or more files corresponding to existing artifacts or new artifacts that will be created upon successful receipt.<br><br> <strong>Business Rules</strong><br> Artifact cannot be saved if the file does not have the following file extensions:      .docx,.doc,.txt,.rtf,.xfdl,.xml,.mht,.mh,tml,.html,.htm,.pdf,.mdb,.accdb,.ppt,     .pptx,.xls,.xlsx,.csv,.log,.jpeg,.jpg,.tiff,.bmp,.tif,.png,.gif,.zip,.rar,.msg,     .vsd,.vsw,.vdx,.z{#},.ckl,.avi,.vsdx  Artifact version cannot be saved if an Artifact with the same file name already exist in the system.  Artifact cannot be saved if the file size exceeds 30MB.
     * @summary Add one or many artifacts in a system
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {any} zipper 
     * @param {boolean} [isTemplate] 
     * @param {string} [type] 
     * @param {string} [category] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public addArtifactsBySystemId(systemId: number, zipper: any, isTemplate?: boolean, type?: string, category?: string, options?: AxiosRequestConfig) {
        return ArtifactsApiFp(this.configuration).addArtifactsBySystemId(systemId, zipper, isTemplate, type, category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove the Artifact(s) matching `systemId` path parameter and request body artifact(s) file name<br><br> <b>Note:</b> Multiple files can be deleted by providing multiple file names at the CL (comma delimited)  Example: --files file1.txt, file2.txt
     * @summary Remove one or many artifacts in a system
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {Array<DeleteArtifactsInner>} [deleteArtifactsInner] Delete artifact files for the given System Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public deleteArtifact(systemId: number, deleteArtifactsInner?: Array<DeleteArtifactsInner>, options?: AxiosRequestConfig) {
        return ArtifactsApiFp(this.configuration).deleteArtifact(systemId, deleteArtifactsInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns selected artifacts matching parameters to include the file name containing the artifacts.
     * @summary Get one or many artifacts in a system
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {string} [filename] **File Name**: The file name (to include file-extension).
     * @param {string} [controlAcronyms] **System Acronym**: Filter query by given system acronym (single or comma separated).
     * @param {string} [ccis] **CCI System**: Filter query by Control Correlation Identifiers (CCIs) (single or comma separated).
     * @param {boolean} [systemOnly] **Systems Only**: Indicates that only system(s) information is retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public getSystemArtifacts(systemId: number, filename?: string, controlAcronyms?: string, ccis?: string, systemOnly?: boolean, options?: AxiosRequestConfig) {
        return ArtifactsApiFp(this.configuration).getSystemArtifacts(systemId, filename, controlAcronyms, ccis, systemOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an artifact for given `systemId` path parameter<br><br>  **Request Body Required Fields** - `filename` - `isTemplate` - `type` - `category`
     * @summary Update one or many artifacts in a system
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {Array<object>} requestBody See &#x60;information&#x60; above for additional instructions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public updateArtifactBySystemId(systemId: number, requestBody: Array<object>, options?: AxiosRequestConfig) {
        return ArtifactsApiFp(this.configuration).updateArtifactBySystemId(systemId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArtifactsExportApi - axios parameter creator
 * @export
 */
export const ArtifactsExportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <strong>Sample Responce</strong><br>  Binary file associated with given filename.<br>  If `compress` parameter is specified, zip archive of binary file associated with given filename.
         * @summary Get the file of an artifact in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {string} filename **File Name**: The file name (to include file-extension).
         * @param {boolean} [compress] **Compress File**: Determines if returned file is compressed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemArtifactsExport: async (systemId: number, filename: string, compress?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('getSystemArtifactsExport', 'systemId', systemId)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getSystemArtifactsExport', 'filename', filename)
            const localVarPath = `/api/systems/{systemId}/artifacts-export`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (compress !== undefined) {
                localVarQueryParameter['compress'] = compress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactsExportApi - functional programming interface
 * @export
 */
export const ArtifactsExportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtifactsExportApiAxiosParamCreator(configuration)
    return {
        /**
         * <strong>Sample Responce</strong><br>  Binary file associated with given filename.<br>  If `compress` parameter is specified, zip archive of binary file associated with given filename.
         * @summary Get the file of an artifact in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {string} filename **File Name**: The file name (to include file-extension).
         * @param {boolean} [compress] **Compress File**: Determines if returned file is compressed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemArtifactsExport(systemId: number, filename: string, compress?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemArtifactsExport(systemId, filename, compress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArtifactsExportApi - factory interface
 * @export
 */
export const ArtifactsExportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtifactsExportApiFp(configuration)
    return {
        /**
         * <strong>Sample Responce</strong><br>  Binary file associated with given filename.<br>  If `compress` parameter is specified, zip archive of binary file associated with given filename.
         * @summary Get the file of an artifact in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {string} filename **File Name**: The file name (to include file-extension).
         * @param {boolean} [compress] **Compress File**: Determines if returned file is compressed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemArtifactsExport(systemId: number, filename: string, compress?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.getSystemArtifactsExport(systemId, filename, compress, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtifactsExportApi - object-oriented interface
 * @export
 * @class ArtifactsExportApi
 * @extends {BaseAPI}
 */
export class ArtifactsExportApi extends BaseAPI {
    /**
     * <strong>Sample Responce</strong><br>  Binary file associated with given filename.<br>  If `compress` parameter is specified, zip archive of binary file associated with given filename.
     * @summary Get the file of an artifact in a system
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {string} filename **File Name**: The file name (to include file-extension).
     * @param {boolean} [compress] **Compress File**: Determines if returned file is compressed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsExportApi
     */
    public getSystemArtifactsExport(systemId: number, filename: string, compress?: boolean, options?: AxiosRequestConfig) {
        return ArtifactsExportApiFp(this.configuration).getSystemArtifactsExport(systemId, filename, compress, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CACApi - axios parameter creator
 * @export
 */
export const CACApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a Control Approval Chain (CAC) for given `systemId` path parameter<br><br> POST requests will only yield successful results if the control is currently sitting at the first role of the CAC. If the control is not currently sitting at the first role, then an error will be returned.
         * @summary Submit control to second role of CAC
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Add control(s) to second role of CAC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSystemCac: async (systemId: number, requestBody: Array<object>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('addSystemCac', 'systemId', systemId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('addSystemCac', 'requestBody', requestBody)
            const localVarPath = `/api/systems/{systemId}/approval/cac`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the location of a system\'s package in the Control Approval Chain (CAC) for matching `systemId` path parameter
         * @summary Get location of one or many controls in CAC
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {string} [controlAcronyms] **System Acronym**: Filter query by given system acronym (single or comma separated).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemCac: async (systemId: number, controlAcronyms?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('getSystemCac', 'systemId', systemId)
            const localVarPath = `/api/systems/{systemId}/approval/cac`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)

            if (controlAcronyms !== undefined) {
                localVarQueryParameter['controlAcronyms'] = controlAcronyms;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CACApi - functional programming interface
 * @export
 */
export const CACApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CACApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a Control Approval Chain (CAC) for given `systemId` path parameter<br><br> POST requests will only yield successful results if the control is currently sitting at the first role of the CAC. If the control is not currently sitting at the first role, then an error will be returned.
         * @summary Submit control to second role of CAC
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Add control(s) to second role of CAC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSystemCac(systemId: number, requestBody: Array<object>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CacResponsePost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSystemCac(systemId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the location of a system\'s package in the Control Approval Chain (CAC) for matching `systemId` path parameter
         * @summary Get location of one or many controls in CAC
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {string} [controlAcronyms] **System Acronym**: Filter query by given system acronym (single or comma separated).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemCac(systemId: number, controlAcronyms?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CacResponseGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemCac(systemId, controlAcronyms, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CACApi - factory interface
 * @export
 */
export const CACApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CACApiFp(configuration)
    return {
        /**
         * Adds a Control Approval Chain (CAC) for given `systemId` path parameter<br><br> POST requests will only yield successful results if the control is currently sitting at the first role of the CAC. If the control is not currently sitting at the first role, then an error will be returned.
         * @summary Submit control to second role of CAC
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Add control(s) to second role of CAC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSystemCac(systemId: number, requestBody: Array<object>, options?: any): AxiosPromise<CacResponsePost> {
            return localVarFp.addSystemCac(systemId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the location of a system\'s package in the Control Approval Chain (CAC) for matching `systemId` path parameter
         * @summary Get location of one or many controls in CAC
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {string} [controlAcronyms] **System Acronym**: Filter query by given system acronym (single or comma separated).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemCac(systemId: number, controlAcronyms?: string, options?: any): AxiosPromise<CacResponseGet> {
            return localVarFp.getSystemCac(systemId, controlAcronyms, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CACApi - object-oriented interface
 * @export
 * @class CACApi
 * @extends {BaseAPI}
 */
export class CACApi extends BaseAPI {
    /**
     * Adds a Control Approval Chain (CAC) for given `systemId` path parameter<br><br> POST requests will only yield successful results if the control is currently sitting at the first role of the CAC. If the control is not currently sitting at the first role, then an error will be returned.
     * @summary Submit control to second role of CAC
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {Array<object>} requestBody Add control(s) to second role of CAC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CACApi
     */
    public addSystemCac(systemId: number, requestBody: Array<object>, options?: AxiosRequestConfig) {
        return CACApiFp(this.configuration).addSystemCac(systemId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the location of a system\'s package in the Control Approval Chain (CAC) for matching `systemId` path parameter
     * @summary Get location of one or many controls in CAC
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {string} [controlAcronyms] **System Acronym**: Filter query by given system acronym (single or comma separated).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CACApi
     */
    public getSystemCac(systemId: number, controlAcronyms?: string, options?: AxiosRequestConfig) {
        return CACApiFp(this.configuration).getSystemCac(systemId, controlAcronyms, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CMMCAssessmentsApi - axios parameter creator
 * @export
 */
export const CMMCAssessmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all CMMC assessment after the given date `sinceDate` parameter. It is available to CMMC eMASS only.
         * @summary Get CMMC assessment information
         * @param {string} sinceDate **Date** CMMC date (Unix date format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmmcAssessments: async (sinceDate: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sinceDate' is not null or undefined
            assertParamExists('getCmmcAssessments', 'sinceDate', sinceDate)
            const localVarPath = `/api/cmmc-assessments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)

            if (sinceDate !== undefined) {
                localVarQueryParameter['sinceDate'] = sinceDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CMMCAssessmentsApi - functional programming interface
 * @export
 */
export const CMMCAssessmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CMMCAssessmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all CMMC assessment after the given date `sinceDate` parameter. It is available to CMMC eMASS only.
         * @summary Get CMMC assessment information
         * @param {string} sinceDate **Date** CMMC date (Unix date format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmmcAssessments(sinceDate: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CmmcResponseGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmmcAssessments(sinceDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CMMCAssessmentsApi - factory interface
 * @export
 */
export const CMMCAssessmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CMMCAssessmentsApiFp(configuration)
    return {
        /**
         * Get all CMMC assessment after the given date `sinceDate` parameter. It is available to CMMC eMASS only.
         * @summary Get CMMC assessment information
         * @param {string} sinceDate **Date** CMMC date (Unix date format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmmcAssessments(sinceDate: string, options?: any): AxiosPromise<CmmcResponseGet> {
            return localVarFp.getCmmcAssessments(sinceDate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CMMCAssessmentsApi - object-oriented interface
 * @export
 * @class CMMCAssessmentsApi
 * @extends {BaseAPI}
 */
export class CMMCAssessmentsApi extends BaseAPI {
    /**
     * Get all CMMC assessment after the given date `sinceDate` parameter. It is available to CMMC eMASS only.
     * @summary Get CMMC assessment information
     * @param {string} sinceDate **Date** CMMC date (Unix date format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CMMCAssessmentsApi
     */
    public getCmmcAssessments(sinceDate: string, options?: AxiosRequestConfig) {
        return CMMCAssessmentsApiFp(this.configuration).getCmmcAssessments(sinceDate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CloudResourcesApi - axios parameter creator
 * @export
 */
export const CloudResourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add cloud resources and their scan results in the assets module for a system `systemId`
         * @summary Add one or many cloud resources and their scan results
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Add cloud resources and their scan results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCloudResourcesBySystemId: async (systemId: number, requestBody: Array<object>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('addCloudResourcesBySystemId', 'systemId', systemId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('addCloudResourcesBySystemId', 'requestBody', requestBody)
            const localVarPath = `/api/systems/{systemId}/cloud-resource-results`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudResourcesApi - functional programming interface
 * @export
 */
export const CloudResourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudResourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * Add cloud resources and their scan results in the assets module for a system `systemId`
         * @summary Add one or many cloud resources and their scan results
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Add cloud resources and their scan results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCloudResourcesBySystemId(systemId: number, requestBody: Array<object>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudResourcesResponsePost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCloudResourcesBySystemId(systemId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CloudResourcesApi - factory interface
 * @export
 */
export const CloudResourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudResourcesApiFp(configuration)
    return {
        /**
         * Add cloud resources and their scan results in the assets module for a system `systemId`
         * @summary Add one or many cloud resources and their scan results
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Add cloud resources and their scan results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCloudResourcesBySystemId(systemId: number, requestBody: Array<object>, options?: any): AxiosPromise<CloudResourcesResponsePost> {
            return localVarFp.addCloudResourcesBySystemId(systemId, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudResourcesApi - object-oriented interface
 * @export
 * @class CloudResourcesApi
 * @extends {BaseAPI}
 */
export class CloudResourcesApi extends BaseAPI {
    /**
     * Add cloud resources and their scan results in the assets module for a system `systemId`
     * @summary Add one or many cloud resources and their scan results
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {Array<object>} requestBody Add cloud resources and their scan results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudResourcesApi
     */
    public addCloudResourcesBySystemId(systemId: number, requestBody: Array<object>, options?: AxiosRequestConfig) {
        return CloudResourcesApiFp(this.configuration).addCloudResourcesBySystemId(systemId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContainersApi - axios parameter creator
 * @export
 */
export const ContainersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add containers and their scan results in the assets module for a system `systemId`.
         * @summary Add one or many containers and their scan results
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Add containers and their scan results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContainerSansBySystemId: async (systemId: number, requestBody: Array<object>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('addContainerSansBySystemId', 'systemId', systemId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('addContainerSansBySystemId', 'requestBody', requestBody)
            const localVarPath = `/api/systems/{systemId}/container-scan-results`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainersApi - functional programming interface
 * @export
 */
export const ContainersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainersApiAxiosParamCreator(configuration)
    return {
        /**
         * Add containers and their scan results in the assets module for a system `systemId`.
         * @summary Add one or many containers and their scan results
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Add containers and their scan results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addContainerSansBySystemId(systemId: number, requestBody: Array<object>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainersResponsePost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addContainerSansBySystemId(systemId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainersApi - factory interface
 * @export
 */
export const ContainersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainersApiFp(configuration)
    return {
        /**
         * Add containers and their scan results in the assets module for a system `systemId`.
         * @summary Add one or many containers and their scan results
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Add containers and their scan results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContainerSansBySystemId(systemId: number, requestBody: Array<object>, options?: any): AxiosPromise<ContainersResponsePost> {
            return localVarFp.addContainerSansBySystemId(systemId, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainersApi - object-oriented interface
 * @export
 * @class ContainersApi
 * @extends {BaseAPI}
 */
export class ContainersApi extends BaseAPI {
    /**
     * Add containers and their scan results in the assets module for a system `systemId`.
     * @summary Add one or many containers and their scan results
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {Array<object>} requestBody Add containers and their scan results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public addContainerSansBySystemId(systemId: number, requestBody: Array<object>, options?: AxiosRequestConfig) {
        return ContainersApiFp(this.configuration).addContainerSansBySystemId(systemId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ControlsApi - axios parameter creator
 * @export
 */
export const ControlsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns system control information for matching `systemId` path parameter
         * @summary Get control information in a system for one or many controls
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {string} [acronyms] **Acronym**: The system acronym(s) being queried (single value or comma delimited values).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemControls: async (systemId: number, acronyms?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('getSystemControls', 'systemId', systemId)
            const localVarPath = `/api/systems/{systemId}/controls`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)

            if (acronyms !== undefined) {
                localVarQueryParameter['acronyms'] = acronyms;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update a Control for given `systemId`<br>  **Request Body Required Fields** - `acronym` - `responsibleEntities` - `controlDesignation` - `estimatedCompletionDate` - `implementationNarrative`  The following optional fields are required based on the Implementation Status `implementationStatus` value<br> | Value                    | Required Fields |--------------------------|--------------------------------------------------- | Planned  or Implemented  | `estimatedCompletionDate`, `responsibleEntities`, `slcmCriticality`, `slcmFrequency`, `slcmMethod`, `slcmReporting`, `slcmTracking`, `slcmComments` | Not Applicable           | `naJustification`, `responsibleEntities` | Manually Inherited       | `commonControlProvider`, `estimatedCompletionDate`, `responsibleEntities`, `slcmCriticality`, `slcmFrequency`, `slcmMethod`, `slcmReporting`, `slcmTracking`, `slcmComments`  If the Implementation Status `implementationStatus` value is `Inherited`, only the following fields can be updated:   - `controlDesignation`   - `commonnControlProvider`
         * @summary Update control information in a system for one or many controls
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Update an existing control by Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateControlBySystemId: async (systemId: number, requestBody: Array<object>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('updateControlBySystemId', 'systemId', systemId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateControlBySystemId', 'requestBody', requestBody)
            const localVarPath = `/api/systems/{systemId}/controls`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ControlsApi - functional programming interface
 * @export
 */
export const ControlsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ControlsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns system control information for matching `systemId` path parameter
         * @summary Get control information in a system for one or many controls
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {string} [acronyms] **Acronym**: The system acronym(s) being queried (single value or comma delimited values).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemControls(systemId: number, acronyms?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControlsResponseGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemControls(systemId, acronyms, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Update a Control for given `systemId`<br>  **Request Body Required Fields** - `acronym` - `responsibleEntities` - `controlDesignation` - `estimatedCompletionDate` - `implementationNarrative`  The following optional fields are required based on the Implementation Status `implementationStatus` value<br> | Value                    | Required Fields |--------------------------|--------------------------------------------------- | Planned  or Implemented  | `estimatedCompletionDate`, `responsibleEntities`, `slcmCriticality`, `slcmFrequency`, `slcmMethod`, `slcmReporting`, `slcmTracking`, `slcmComments` | Not Applicable           | `naJustification`, `responsibleEntities` | Manually Inherited       | `commonControlProvider`, `estimatedCompletionDate`, `responsibleEntities`, `slcmCriticality`, `slcmFrequency`, `slcmMethod`, `slcmReporting`, `slcmTracking`, `slcmComments`  If the Implementation Status `implementationStatus` value is `Inherited`, only the following fields can be updated:   - `controlDesignation`   - `commonnControlProvider`
         * @summary Update control information in a system for one or many controls
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Update an existing control by Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateControlBySystemId(systemId: number, requestBody: Array<object>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControlsResponsePut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateControlBySystemId(systemId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ControlsApi - factory interface
 * @export
 */
export const ControlsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ControlsApiFp(configuration)
    return {
        /**
         * Returns system control information for matching `systemId` path parameter
         * @summary Get control information in a system for one or many controls
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {string} [acronyms] **Acronym**: The system acronym(s) being queried (single value or comma delimited values).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemControls(systemId: number, acronyms?: string, options?: any): AxiosPromise<ControlsResponseGet> {
            return localVarFp.getSystemControls(systemId, acronyms, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update a Control for given `systemId`<br>  **Request Body Required Fields** - `acronym` - `responsibleEntities` - `controlDesignation` - `estimatedCompletionDate` - `implementationNarrative`  The following optional fields are required based on the Implementation Status `implementationStatus` value<br> | Value                    | Required Fields |--------------------------|--------------------------------------------------- | Planned  or Implemented  | `estimatedCompletionDate`, `responsibleEntities`, `slcmCriticality`, `slcmFrequency`, `slcmMethod`, `slcmReporting`, `slcmTracking`, `slcmComments` | Not Applicable           | `naJustification`, `responsibleEntities` | Manually Inherited       | `commonControlProvider`, `estimatedCompletionDate`, `responsibleEntities`, `slcmCriticality`, `slcmFrequency`, `slcmMethod`, `slcmReporting`, `slcmTracking`, `slcmComments`  If the Implementation Status `implementationStatus` value is `Inherited`, only the following fields can be updated:   - `controlDesignation`   - `commonnControlProvider`
         * @summary Update control information in a system for one or many controls
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Update an existing control by Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateControlBySystemId(systemId: number, requestBody: Array<object>, options?: any): AxiosPromise<ControlsResponsePut> {
            return localVarFp.updateControlBySystemId(systemId, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ControlsApi - object-oriented interface
 * @export
 * @class ControlsApi
 * @extends {BaseAPI}
 */
export class ControlsApi extends BaseAPI {
    /**
     * Returns system control information for matching `systemId` path parameter
     * @summary Get control information in a system for one or many controls
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {string} [acronyms] **Acronym**: The system acronym(s) being queried (single value or comma delimited values).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ControlsApi
     */
    public getSystemControls(systemId: number, acronyms?: string, options?: AxiosRequestConfig) {
        return ControlsApiFp(this.configuration).getSystemControls(systemId, acronyms, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update a Control for given `systemId`<br>  **Request Body Required Fields** - `acronym` - `responsibleEntities` - `controlDesignation` - `estimatedCompletionDate` - `implementationNarrative`  The following optional fields are required based on the Implementation Status `implementationStatus` value<br> | Value                    | Required Fields |--------------------------|--------------------------------------------------- | Planned  or Implemented  | `estimatedCompletionDate`, `responsibleEntities`, `slcmCriticality`, `slcmFrequency`, `slcmMethod`, `slcmReporting`, `slcmTracking`, `slcmComments` | Not Applicable           | `naJustification`, `responsibleEntities` | Manually Inherited       | `commonControlProvider`, `estimatedCompletionDate`, `responsibleEntities`, `slcmCriticality`, `slcmFrequency`, `slcmMethod`, `slcmReporting`, `slcmTracking`, `slcmComments`  If the Implementation Status `implementationStatus` value is `Inherited`, only the following fields can be updated:   - `controlDesignation`   - `commonnControlProvider`
     * @summary Update control information in a system for one or many controls
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {Array<object>} requestBody Update an existing control by Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ControlsApi
     */
    public updateControlBySystemId(systemId: number, requestBody: Array<object>, options?: AxiosRequestConfig) {
        return ControlsApiFp(this.configuration).updateControlBySystemId(systemId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MilestonesApi - axios parameter creator
 * @export
 */
export const MilestonesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a milestone for given `systemId` and `poamId` path parameters  **Request Body Required Fields** - `description` - `scheduledCompletionDate`
         * @summary Add milestones to one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
         * @param {Array<object>} requestBody Add milestones to an existing system poam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMilestoneBySystemIdAndPoamId: async (systemId: number, poamId: number, requestBody: Array<object>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('addMilestoneBySystemIdAndPoamId', 'systemId', systemId)
            // verify required parameter 'poamId' is not null or undefined
            assertParamExists('addMilestoneBySystemIdAndPoamId', 'poamId', poamId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('addMilestoneBySystemIdAndPoamId', 'requestBody', requestBody)
            const localVarPath = `/api/systems/{systemId}/poams/{poamId}/milestones`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)))
                .replace(`{${"poamId"}}`, encodeURIComponent(String(poamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the POA&M matching `systemId` and `poamId` for path parameters and `milstoneId` provide in the Requst Body  **Notes**<br> To delete a milestone the record must be inactive by having the field isActive set to false (`isActive=false`).
         * @summary Remove milestones in a system for one or many POA&M items
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
         * @param {Array<DeletePoamsInner1>} deletePoamsInner1 Delete the given Milestone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMilestone: async (systemId: number, poamId: number, deletePoamsInner1: Array<DeletePoamsInner1>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('deleteMilestone', 'systemId', systemId)
            // verify required parameter 'poamId' is not null or undefined
            assertParamExists('deleteMilestone', 'poamId', poamId)
            // verify required parameter 'deletePoamsInner1' is not null or undefined
            assertParamExists('deleteMilestone', 'deletePoamsInner1', deletePoamsInner1)
            const localVarPath = `/api/systems/{systemId}/poams/{poamId}/milestones`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)))
                .replace(`{${"poamId"}}`, encodeURIComponent(String(poamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deletePoamsInner1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns system containing milestones for matching parameters.
         * @summary Get milestones in one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
         * @param {string} [scheduledCompletionDateStart] **Date Started**: Filter query by the scheduled completion start date (Unix date format).
         * @param {string} [scheduledCompletionDateEnd] **Date Ended**: Filter query by the scheduled completion start date (Unix date format).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemMilestonesByPoamId: async (systemId: number, poamId: number, scheduledCompletionDateStart?: string, scheduledCompletionDateEnd?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('getSystemMilestonesByPoamId', 'systemId', systemId)
            // verify required parameter 'poamId' is not null or undefined
            assertParamExists('getSystemMilestonesByPoamId', 'poamId', poamId)
            const localVarPath = `/api/systems/{systemId}/poams/{poamId}/milestones`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)))
                .replace(`{${"poamId"}}`, encodeURIComponent(String(poamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)

            if (scheduledCompletionDateStart !== undefined) {
                localVarQueryParameter['scheduledCompletionDateStart'] = scheduledCompletionDateStart;
            }

            if (scheduledCompletionDateEnd !== undefined) {
                localVarQueryParameter['scheduledCompletionDateEnd'] = scheduledCompletionDateEnd;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns systems containing milestones for matching parameters.
         * @summary Get milestone by ID in POA&M item in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
         * @param {number} milestoneId **Milestone Id**: The unique milestone record identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemMilestonesByPoamIdAndMilestoneId: async (systemId: number, poamId: number, milestoneId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('getSystemMilestonesByPoamIdAndMilestoneId', 'systemId', systemId)
            // verify required parameter 'poamId' is not null or undefined
            assertParamExists('getSystemMilestonesByPoamIdAndMilestoneId', 'poamId', poamId)
            // verify required parameter 'milestoneId' is not null or undefined
            assertParamExists('getSystemMilestonesByPoamIdAndMilestoneId', 'milestoneId', milestoneId)
            const localVarPath = `/api/systems/{systemId}/poams/{poamId}/milestones/{milestoneId}`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)))
                .replace(`{${"poamId"}}`, encodeURIComponent(String(poamId)))
                .replace(`{${"milestoneId"}}`, encodeURIComponent(String(milestoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a milestone for given `systemId` and `poamId` path parameters  **Request Body Required Fields** - `milestoneId` - `description` - `scheduledCompletionDate`
         * @summary Update one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
         * @param {Array<object>} requestBody Update milestones for an existing system poam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMilestoneBySystemIdAndPoamId: async (systemId: number, poamId: number, requestBody: Array<object>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('updateMilestoneBySystemIdAndPoamId', 'systemId', systemId)
            // verify required parameter 'poamId' is not null or undefined
            assertParamExists('updateMilestoneBySystemIdAndPoamId', 'poamId', poamId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateMilestoneBySystemIdAndPoamId', 'requestBody', requestBody)
            const localVarPath = `/api/systems/{systemId}/poams/{poamId}/milestones`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)))
                .replace(`{${"poamId"}}`, encodeURIComponent(String(poamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MilestonesApi - functional programming interface
 * @export
 */
export const MilestonesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MilestonesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a milestone for given `systemId` and `poamId` path parameters  **Request Body Required Fields** - `description` - `scheduledCompletionDate`
         * @summary Add milestones to one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
         * @param {Array<object>} requestBody Add milestones to an existing system poam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMilestoneBySystemIdAndPoamId(systemId: number, poamId: number, requestBody: Array<object>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MilestoneResponsePost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMilestoneBySystemIdAndPoamId(systemId, poamId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove the POA&M matching `systemId` and `poamId` for path parameters and `milstoneId` provide in the Requst Body  **Notes**<br> To delete a milestone the record must be inactive by having the field isActive set to false (`isActive=false`).
         * @summary Remove milestones in a system for one or many POA&M items
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
         * @param {Array<DeletePoamsInner1>} deletePoamsInner1 Delete the given Milestone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMilestone(systemId: number, poamId: number, deletePoamsInner1: Array<DeletePoamsInner1>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MilestonesPutPostDelete>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMilestone(systemId, poamId, deletePoamsInner1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns system containing milestones for matching parameters.
         * @summary Get milestones in one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
         * @param {string} [scheduledCompletionDateStart] **Date Started**: Filter query by the scheduled completion start date (Unix date format).
         * @param {string} [scheduledCompletionDateEnd] **Date Ended**: Filter query by the scheduled completion start date (Unix date format).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemMilestonesByPoamId(systemId: number, poamId: number, scheduledCompletionDateStart?: string, scheduledCompletionDateEnd?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MilestoneResponseGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemMilestonesByPoamId(systemId, poamId, scheduledCompletionDateStart, scheduledCompletionDateEnd, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns systems containing milestones for matching parameters.
         * @summary Get milestone by ID in POA&M item in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
         * @param {number} milestoneId **Milestone Id**: The unique milestone record identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemMilestonesByPoamIdAndMilestoneId(systemId: number, poamId: number, milestoneId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MilestoneResponseGetMilestone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemMilestonesByPoamIdAndMilestoneId(systemId, poamId, milestoneId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a milestone for given `systemId` and `poamId` path parameters  **Request Body Required Fields** - `milestoneId` - `description` - `scheduledCompletionDate`
         * @summary Update one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
         * @param {Array<object>} requestBody Update milestones for an existing system poam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMilestoneBySystemIdAndPoamId(systemId: number, poamId: number, requestBody: Array<object>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MilestoneResponsePut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMilestoneBySystemIdAndPoamId(systemId, poamId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MilestonesApi - factory interface
 * @export
 */
export const MilestonesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MilestonesApiFp(configuration)
    return {
        /**
         * Adds a milestone for given `systemId` and `poamId` path parameters  **Request Body Required Fields** - `description` - `scheduledCompletionDate`
         * @summary Add milestones to one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
         * @param {Array<object>} requestBody Add milestones to an existing system poam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMilestoneBySystemIdAndPoamId(systemId: number, poamId: number, requestBody: Array<object>, options?: any): AxiosPromise<MilestoneResponsePost> {
            return localVarFp.addMilestoneBySystemIdAndPoamId(systemId, poamId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove the POA&M matching `systemId` and `poamId` for path parameters and `milstoneId` provide in the Requst Body  **Notes**<br> To delete a milestone the record must be inactive by having the field isActive set to false (`isActive=false`).
         * @summary Remove milestones in a system for one or many POA&M items
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
         * @param {Array<DeletePoamsInner1>} deletePoamsInner1 Delete the given Milestone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMilestone(systemId: number, poamId: number, deletePoamsInner1: Array<DeletePoamsInner1>, options?: any): AxiosPromise<MilestonesPutPostDelete> {
            return localVarFp.deleteMilestone(systemId, poamId, deletePoamsInner1, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns system containing milestones for matching parameters.
         * @summary Get milestones in one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
         * @param {string} [scheduledCompletionDateStart] **Date Started**: Filter query by the scheduled completion start date (Unix date format).
         * @param {string} [scheduledCompletionDateEnd] **Date Ended**: Filter query by the scheduled completion start date (Unix date format).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemMilestonesByPoamId(systemId: number, poamId: number, scheduledCompletionDateStart?: string, scheduledCompletionDateEnd?: string, options?: any): AxiosPromise<MilestoneResponseGet> {
            return localVarFp.getSystemMilestonesByPoamId(systemId, poamId, scheduledCompletionDateStart, scheduledCompletionDateEnd, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns systems containing milestones for matching parameters.
         * @summary Get milestone by ID in POA&M item in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
         * @param {number} milestoneId **Milestone Id**: The unique milestone record identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemMilestonesByPoamIdAndMilestoneId(systemId: number, poamId: number, milestoneId: number, options?: any): AxiosPromise<MilestoneResponseGetMilestone> {
            return localVarFp.getSystemMilestonesByPoamIdAndMilestoneId(systemId, poamId, milestoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a milestone for given `systemId` and `poamId` path parameters  **Request Body Required Fields** - `milestoneId` - `description` - `scheduledCompletionDate`
         * @summary Update one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
         * @param {Array<object>} requestBody Update milestones for an existing system poam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMilestoneBySystemIdAndPoamId(systemId: number, poamId: number, requestBody: Array<object>, options?: any): AxiosPromise<MilestoneResponsePut> {
            return localVarFp.updateMilestoneBySystemIdAndPoamId(systemId, poamId, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MilestonesApi - object-oriented interface
 * @export
 * @class MilestonesApi
 * @extends {BaseAPI}
 */
export class MilestonesApi extends BaseAPI {
    /**
     * Adds a milestone for given `systemId` and `poamId` path parameters  **Request Body Required Fields** - `description` - `scheduledCompletionDate`
     * @summary Add milestones to one or many POA&M items in a system
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
     * @param {Array<object>} requestBody Add milestones to an existing system poam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestonesApi
     */
    public addMilestoneBySystemIdAndPoamId(systemId: number, poamId: number, requestBody: Array<object>, options?: AxiosRequestConfig) {
        return MilestonesApiFp(this.configuration).addMilestoneBySystemIdAndPoamId(systemId, poamId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove the POA&M matching `systemId` and `poamId` for path parameters and `milstoneId` provide in the Requst Body  **Notes**<br> To delete a milestone the record must be inactive by having the field isActive set to false (`isActive=false`).
     * @summary Remove milestones in a system for one or many POA&M items
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
     * @param {Array<DeletePoamsInner1>} deletePoamsInner1 Delete the given Milestone Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestonesApi
     */
    public deleteMilestone(systemId: number, poamId: number, deletePoamsInner1: Array<DeletePoamsInner1>, options?: AxiosRequestConfig) {
        return MilestonesApiFp(this.configuration).deleteMilestone(systemId, poamId, deletePoamsInner1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns system containing milestones for matching parameters.
     * @summary Get milestones in one or many POA&M items in a system
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
     * @param {string} [scheduledCompletionDateStart] **Date Started**: Filter query by the scheduled completion start date (Unix date format).
     * @param {string} [scheduledCompletionDateEnd] **Date Ended**: Filter query by the scheduled completion start date (Unix date format).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestonesApi
     */
    public getSystemMilestonesByPoamId(systemId: number, poamId: number, scheduledCompletionDateStart?: string, scheduledCompletionDateEnd?: string, options?: AxiosRequestConfig) {
        return MilestonesApiFp(this.configuration).getSystemMilestonesByPoamId(systemId, poamId, scheduledCompletionDateStart, scheduledCompletionDateEnd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns systems containing milestones for matching parameters.
     * @summary Get milestone by ID in POA&M item in a system
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
     * @param {number} milestoneId **Milestone Id**: The unique milestone record identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestonesApi
     */
    public getSystemMilestonesByPoamIdAndMilestoneId(systemId: number, poamId: number, milestoneId: number, options?: AxiosRequestConfig) {
        return MilestonesApiFp(this.configuration).getSystemMilestonesByPoamIdAndMilestoneId(systemId, poamId, milestoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a milestone for given `systemId` and `poamId` path parameters  **Request Body Required Fields** - `milestoneId` - `description` - `scheduledCompletionDate`
     * @summary Update one or many POA&M items in a system
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
     * @param {Array<object>} requestBody Update milestones for an existing system poam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestonesApi
     */
    public updateMilestoneBySystemIdAndPoamId(systemId: number, poamId: number, requestBody: Array<object>, options?: AxiosRequestConfig) {
        return MilestonesApiFp(this.configuration).updateMilestoneBySystemIdAndPoamId(systemId, poamId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PACApi - axios parameter creator
 * @export
 */
export const PACApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a Package Approval Chain (PAC) for given `systemId` path parameter
         * @summary Submit system package for review
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Add system package to PAC for review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSystemPac: async (systemId: number, requestBody: Array<object>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('addSystemPac', 'systemId', systemId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('addSystemPac', 'requestBody', requestBody)
            const localVarPath = `/api/systems/{systemId}/approval/pac`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the location of a system\'s package in the Package Approval Chain (PAC) for matching `systemId` path parameter
         * @summary Get location of system package in PAC
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemPac: async (systemId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('getSystemPac', 'systemId', systemId)
            const localVarPath = `/api/systems/{systemId}/approval/pac`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PACApi - functional programming interface
 * @export
 */
export const PACApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PACApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a Package Approval Chain (PAC) for given `systemId` path parameter
         * @summary Submit system package for review
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Add system package to PAC for review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSystemPac(systemId: number, requestBody: Array<object>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PacResponsePost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSystemPac(systemId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the location of a system\'s package in the Package Approval Chain (PAC) for matching `systemId` path parameter
         * @summary Get location of system package in PAC
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemPac(systemId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PacResponseGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemPac(systemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PACApi - factory interface
 * @export
 */
export const PACApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PACApiFp(configuration)
    return {
        /**
         * Adds a Package Approval Chain (PAC) for given `systemId` path parameter
         * @summary Submit system package for review
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Add system package to PAC for review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSystemPac(systemId: number, requestBody: Array<object>, options?: any): AxiosPromise<PacResponsePost> {
            return localVarFp.addSystemPac(systemId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the location of a system\'s package in the Package Approval Chain (PAC) for matching `systemId` path parameter
         * @summary Get location of system package in PAC
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemPac(systemId: number, options?: any): AxiosPromise<PacResponseGet> {
            return localVarFp.getSystemPac(systemId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PACApi - object-oriented interface
 * @export
 * @class PACApi
 * @extends {BaseAPI}
 */
export class PACApi extends BaseAPI {
    /**
     * Adds a Package Approval Chain (PAC) for given `systemId` path parameter
     * @summary Submit system package for review
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {Array<object>} requestBody Add system package to PAC for review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PACApi
     */
    public addSystemPac(systemId: number, requestBody: Array<object>, options?: AxiosRequestConfig) {
        return PACApiFp(this.configuration).addSystemPac(systemId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the location of a system\'s package in the Package Approval Chain (PAC) for matching `systemId` path parameter
     * @summary Get location of system package in PAC
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PACApi
     */
    public getSystemPac(systemId: number, options?: AxiosRequestConfig) {
        return PACApiFp(this.configuration).getSystemPac(systemId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * POAMApi - axios parameter creator
 * @export
 */
export const POAMApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a POA&M for given `systemId`<br>  **Request Body Required Fields** - `status` - `vulnerabilityDescription` - `sourceIdentVuln` - `pocOrganization` - `resources`  **Note**<br /> If a POC email is supplied, the application will attempt to locate a user already registered within the application and pre-populate any information not explicitly supplied in the request. If no such user is found, these fields are **required** within the request.<br> `pocFirstName`, `pocLastName`, `pocPhoneNumber`<br />
         * @summary Add one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Add POA&amp;M(s) to a system (systemID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPoamBySystemId: async (systemId: number, requestBody: Array<object>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('addPoamBySystemId', 'systemId', systemId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('addPoamBySystemId', 'requestBody', requestBody)
            const localVarPath = `/api/systems/{systemId}/poams`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the POA&M matching `systemId` path parameter and `poamId` Request Body<br>
         * @summary Remove one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<DeletePoamsInner>} deletePoamsInner Delete the given POA&amp;M Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePoam: async (systemId: number, deletePoamsInner: Array<DeletePoamsInner>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('deletePoam', 'systemId', systemId)
            // verify required parameter 'deletePoamsInner' is not null or undefined
            assertParamExists('deletePoam', 'deletePoamsInner', deletePoamsInner)
            const localVarPath = `/api/systems/{systemId}/poams`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deletePoamsInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns system(s) containing POA&M items for matching parameters.
         * @summary Get one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {string} [scheduledCompletionDateStart] **Date Started**: Filter query by the scheduled completion start date (Unix date format).
         * @param {string} [scheduledCompletionDateEnd] **Date Ended**: Filter query by the scheduled completion start date (Unix date format).
         * @param {string} [controlAcronyms] **System Acronym**: Filter query by given system acronym (single or comma separated).
         * @param {string} [ccis] **CCI System**: Filter query by Control Correlation Identifiers (CCIs) (single or comma separated).
         * @param {boolean} [systemOnly] **Systems Only**: Indicates that only system(s) information is retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemPoams: async (systemId: number, scheduledCompletionDateStart?: string, scheduledCompletionDateEnd?: string, controlAcronyms?: string, ccis?: string, systemOnly?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('getSystemPoams', 'systemId', systemId)
            const localVarPath = `/api/systems/{systemId}/poams`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)

            if (scheduledCompletionDateStart !== undefined) {
                localVarQueryParameter['scheduledCompletionDateStart'] = scheduledCompletionDateStart;
            }

            if (scheduledCompletionDateEnd !== undefined) {
                localVarQueryParameter['scheduledCompletionDateEnd'] = scheduledCompletionDateEnd;
            }

            if (controlAcronyms !== undefined) {
                localVarQueryParameter['controlAcronyms'] = controlAcronyms;
            }

            if (ccis !== undefined) {
                localVarQueryParameter['ccis'] = ccis;
            }

            if (systemOnly !== undefined) {
                localVarQueryParameter['systemOnly'] = systemOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns system(s) containing POA&M items for matching parameters.
         * @summary Get POA&M item by ID in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemPoamsByPoamId: async (systemId: number, poamId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('getSystemPoamsByPoamId', 'systemId', systemId)
            // verify required parameter 'poamId' is not null or undefined
            assertParamExists('getSystemPoamsByPoamId', 'poamId', poamId)
            const localVarPath = `/api/systems/{systemId}/poams/{poamId}`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)))
                .replace(`{${"poamId"}}`, encodeURIComponent(String(poamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a POA&M for given `systemId`<br>  **Request Body Required Fields** - `poamId` - `displayPoamId` - `status` - `vulnerabilityDescription` - `sourceIdentVuln` - `pocOrganization` - `reviewStatus`  **Notes** - If a POC email is supplied, the application will attempt to locate a user already   registered within the application and pre-populate any information not explicitly supplied   in the request. If no such user is found, these fields are **required** within the request.<br>   `pocOrganization`, `pocFirstName`, `pocLastName`, `pocEmail`, `pocPhoneNumber`<br />  - To delete a milestone through the POA&M PUT the field `isActive` must be set to `false`: `isActive=false`.
         * @summary Update one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Update an existing control by Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePoamBySystemId: async (systemId: number, requestBody: Array<object>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('updatePoamBySystemId', 'systemId', systemId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updatePoamBySystemId', 'requestBody', requestBody)
            const localVarPath = `/api/systems/{systemId}/poams`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * POAMApi - functional programming interface
 * @export
 */
export const POAMApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = POAMApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a POA&M for given `systemId`<br>  **Request Body Required Fields** - `status` - `vulnerabilityDescription` - `sourceIdentVuln` - `pocOrganization` - `resources`  **Note**<br /> If a POC email is supplied, the application will attempt to locate a user already registered within the application and pre-populate any information not explicitly supplied in the request. If no such user is found, these fields are **required** within the request.<br> `pocFirstName`, `pocLastName`, `pocPhoneNumber`<br />
         * @summary Add one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Add POA&amp;M(s) to a system (systemID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPoamBySystemId(systemId: number, requestBody: Array<object>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoamResponsePost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPoamBySystemId(systemId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove the POA&M matching `systemId` path parameter and `poamId` Request Body<br>
         * @summary Remove one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<DeletePoamsInner>} deletePoamsInner Delete the given POA&amp;M Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePoam(systemId: number, deletePoamsInner: Array<DeletePoamsInner>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoamResponseDelete>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePoam(systemId, deletePoamsInner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns system(s) containing POA&M items for matching parameters.
         * @summary Get one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {string} [scheduledCompletionDateStart] **Date Started**: Filter query by the scheduled completion start date (Unix date format).
         * @param {string} [scheduledCompletionDateEnd] **Date Ended**: Filter query by the scheduled completion start date (Unix date format).
         * @param {string} [controlAcronyms] **System Acronym**: Filter query by given system acronym (single or comma separated).
         * @param {string} [ccis] **CCI System**: Filter query by Control Correlation Identifiers (CCIs) (single or comma separated).
         * @param {boolean} [systemOnly] **Systems Only**: Indicates that only system(s) information is retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemPoams(systemId: number, scheduledCompletionDateStart?: string, scheduledCompletionDateEnd?: string, controlAcronyms?: string, ccis?: string, systemOnly?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoamResponseGetSystems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemPoams(systemId, scheduledCompletionDateStart, scheduledCompletionDateEnd, controlAcronyms, ccis, systemOnly, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns system(s) containing POA&M items for matching parameters.
         * @summary Get POA&M item by ID in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemPoamsByPoamId(systemId: number, poamId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoamResponseGetPoams>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemPoamsByPoamId(systemId, poamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a POA&M for given `systemId`<br>  **Request Body Required Fields** - `poamId` - `displayPoamId` - `status` - `vulnerabilityDescription` - `sourceIdentVuln` - `pocOrganization` - `reviewStatus`  **Notes** - If a POC email is supplied, the application will attempt to locate a user already   registered within the application and pre-populate any information not explicitly supplied   in the request. If no such user is found, these fields are **required** within the request.<br>   `pocOrganization`, `pocFirstName`, `pocLastName`, `pocEmail`, `pocPhoneNumber`<br />  - To delete a milestone through the POA&M PUT the field `isActive` must be set to `false`: `isActive=false`.
         * @summary Update one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Update an existing control by Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePoamBySystemId(systemId: number, requestBody: Array<object>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoamResponsePut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePoamBySystemId(systemId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * POAMApi - factory interface
 * @export
 */
export const POAMApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = POAMApiFp(configuration)
    return {
        /**
         * Add a POA&M for given `systemId`<br>  **Request Body Required Fields** - `status` - `vulnerabilityDescription` - `sourceIdentVuln` - `pocOrganization` - `resources`  **Note**<br /> If a POC email is supplied, the application will attempt to locate a user already registered within the application and pre-populate any information not explicitly supplied in the request. If no such user is found, these fields are **required** within the request.<br> `pocFirstName`, `pocLastName`, `pocPhoneNumber`<br />
         * @summary Add one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Add POA&amp;M(s) to a system (systemID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPoamBySystemId(systemId: number, requestBody: Array<object>, options?: any): AxiosPromise<PoamResponsePost> {
            return localVarFp.addPoamBySystemId(systemId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove the POA&M matching `systemId` path parameter and `poamId` Request Body<br>
         * @summary Remove one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<DeletePoamsInner>} deletePoamsInner Delete the given POA&amp;M Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePoam(systemId: number, deletePoamsInner: Array<DeletePoamsInner>, options?: any): AxiosPromise<PoamResponseDelete> {
            return localVarFp.deletePoam(systemId, deletePoamsInner, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns system(s) containing POA&M items for matching parameters.
         * @summary Get one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {string} [scheduledCompletionDateStart] **Date Started**: Filter query by the scheduled completion start date (Unix date format).
         * @param {string} [scheduledCompletionDateEnd] **Date Ended**: Filter query by the scheduled completion start date (Unix date format).
         * @param {string} [controlAcronyms] **System Acronym**: Filter query by given system acronym (single or comma separated).
         * @param {string} [ccis] **CCI System**: Filter query by Control Correlation Identifiers (CCIs) (single or comma separated).
         * @param {boolean} [systemOnly] **Systems Only**: Indicates that only system(s) information is retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemPoams(systemId: number, scheduledCompletionDateStart?: string, scheduledCompletionDateEnd?: string, controlAcronyms?: string, ccis?: string, systemOnly?: boolean, options?: any): AxiosPromise<PoamResponseGetSystems> {
            return localVarFp.getSystemPoams(systemId, scheduledCompletionDateStart, scheduledCompletionDateEnd, controlAcronyms, ccis, systemOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns system(s) containing POA&M items for matching parameters.
         * @summary Get POA&M item by ID in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemPoamsByPoamId(systemId: number, poamId: number, options?: any): AxiosPromise<PoamResponseGetPoams> {
            return localVarFp.getSystemPoamsByPoamId(systemId, poamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a POA&M for given `systemId`<br>  **Request Body Required Fields** - `poamId` - `displayPoamId` - `status` - `vulnerabilityDescription` - `sourceIdentVuln` - `pocOrganization` - `reviewStatus`  **Notes** - If a POC email is supplied, the application will attempt to locate a user already   registered within the application and pre-populate any information not explicitly supplied   in the request. If no such user is found, these fields are **required** within the request.<br>   `pocOrganization`, `pocFirstName`, `pocLastName`, `pocEmail`, `pocPhoneNumber`<br />  - To delete a milestone through the POA&M PUT the field `isActive` must be set to `false`: `isActive=false`.
         * @summary Update one or many POA&M items in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Update an existing control by Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePoamBySystemId(systemId: number, requestBody: Array<object>, options?: any): AxiosPromise<PoamResponsePut> {
            return localVarFp.updatePoamBySystemId(systemId, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * POAMApi - object-oriented interface
 * @export
 * @class POAMApi
 * @extends {BaseAPI}
 */
export class POAMApi extends BaseAPI {
    /**
     * Add a POA&M for given `systemId`<br>  **Request Body Required Fields** - `status` - `vulnerabilityDescription` - `sourceIdentVuln` - `pocOrganization` - `resources`  **Note**<br /> If a POC email is supplied, the application will attempt to locate a user already registered within the application and pre-populate any information not explicitly supplied in the request. If no such user is found, these fields are **required** within the request.<br> `pocFirstName`, `pocLastName`, `pocPhoneNumber`<br />
     * @summary Add one or many POA&M items in a system
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {Array<object>} requestBody Add POA&amp;M(s) to a system (systemID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof POAMApi
     */
    public addPoamBySystemId(systemId: number, requestBody: Array<object>, options?: AxiosRequestConfig) {
        return POAMApiFp(this.configuration).addPoamBySystemId(systemId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove the POA&M matching `systemId` path parameter and `poamId` Request Body<br>
     * @summary Remove one or many POA&M items in a system
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {Array<DeletePoamsInner>} deletePoamsInner Delete the given POA&amp;M Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof POAMApi
     */
    public deletePoam(systemId: number, deletePoamsInner: Array<DeletePoamsInner>, options?: AxiosRequestConfig) {
        return POAMApiFp(this.configuration).deletePoam(systemId, deletePoamsInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns system(s) containing POA&M items for matching parameters.
     * @summary Get one or many POA&M items in a system
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {string} [scheduledCompletionDateStart] **Date Started**: Filter query by the scheduled completion start date (Unix date format).
     * @param {string} [scheduledCompletionDateEnd] **Date Ended**: Filter query by the scheduled completion start date (Unix date format).
     * @param {string} [controlAcronyms] **System Acronym**: Filter query by given system acronym (single or comma separated).
     * @param {string} [ccis] **CCI System**: Filter query by Control Correlation Identifiers (CCIs) (single or comma separated).
     * @param {boolean} [systemOnly] **Systems Only**: Indicates that only system(s) information is retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof POAMApi
     */
    public getSystemPoams(systemId: number, scheduledCompletionDateStart?: string, scheduledCompletionDateEnd?: string, controlAcronyms?: string, ccis?: string, systemOnly?: boolean, options?: AxiosRequestConfig) {
        return POAMApiFp(this.configuration).getSystemPoams(systemId, scheduledCompletionDateStart, scheduledCompletionDateEnd, controlAcronyms, ccis, systemOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns system(s) containing POA&M items for matching parameters.
     * @summary Get POA&M item by ID in a system
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {number} poamId **POA&amp;M Id**: The unique POA&amp;M record identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof POAMApi
     */
    public getSystemPoamsByPoamId(systemId: number, poamId: number, options?: AxiosRequestConfig) {
        return POAMApiFp(this.configuration).getSystemPoamsByPoamId(systemId, poamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a POA&M for given `systemId`<br>  **Request Body Required Fields** - `poamId` - `displayPoamId` - `status` - `vulnerabilityDescription` - `sourceIdentVuln` - `pocOrganization` - `reviewStatus`  **Notes** - If a POC email is supplied, the application will attempt to locate a user already   registered within the application and pre-populate any information not explicitly supplied   in the request. If no such user is found, these fields are **required** within the request.<br>   `pocOrganization`, `pocFirstName`, `pocLastName`, `pocEmail`, `pocPhoneNumber`<br />  - To delete a milestone through the POA&M PUT the field `isActive` must be set to `false`: `isActive=false`.
     * @summary Update one or many POA&M items in a system
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {Array<object>} requestBody Update an existing control by Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof POAMApi
     */
    public updatePoamBySystemId(systemId: number, requestBody: Array<object>, options?: AxiosRequestConfig) {
        return POAMApiFp(this.configuration).updatePoamBySystemId(systemId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegistrationApi - axios parameter creator
 * @export
 */
export const RegistrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the api-key - This API key must be provided in the request header for all endpoint calls (api-key).
         * @summary Register user certificate and obtain an API key
         * @param {RegisterUserRequestPostBody} registerUserRequestPostBody User certificate previously provided by eMASS.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (registerUserRequestPostBody: RegisterUserRequestPostBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerUserRequestPostBody' is not null or undefined
            assertParamExists('registerUser', 'registerUserRequestPostBody', registerUserRequestPostBody)
            const localVarPath = `/api/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUserRequestPostBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistrationApi - functional programming interface
 * @export
 */
export const RegistrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegistrationApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the api-key - This API key must be provided in the request header for all endpoint calls (api-key).
         * @summary Register user certificate and obtain an API key
         * @param {RegisterUserRequestPostBody} registerUserRequestPostBody User certificate previously provided by eMASS.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(registerUserRequestPostBody: RegisterUserRequestPostBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Register>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(registerUserRequestPostBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegistrationApi - factory interface
 * @export
 */
export const RegistrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegistrationApiFp(configuration)
    return {
        /**
         * Returns the api-key - This API key must be provided in the request header for all endpoint calls (api-key).
         * @summary Register user certificate and obtain an API key
         * @param {RegisterUserRequestPostBody} registerUserRequestPostBody User certificate previously provided by eMASS.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(registerUserRequestPostBody: RegisterUserRequestPostBody, options?: any): AxiosPromise<Register> {
            return localVarFp.registerUser(registerUserRequestPostBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegistrationApi - object-oriented interface
 * @export
 * @class RegistrationApi
 * @extends {BaseAPI}
 */
export class RegistrationApi extends BaseAPI {
    /**
     * Returns the api-key - This API key must be provided in the request header for all endpoint calls (api-key).
     * @summary Register user certificate and obtain an API key
     * @param {RegisterUserRequestPostBody} registerUserRequestPostBody User certificate previously provided by eMASS.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationApi
     */
    public registerUser(registerUserRequestPostBody: RegisterUserRequestPostBody, options?: AxiosRequestConfig) {
        return RegistrationApiFp(this.configuration).registerUser(registerUserRequestPostBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StaticCodeScansApi - axios parameter creator
 * @export
 */
export const StaticCodeScansApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upload or clear application scan findings into a system\'s `systemId` assets module.  **Note:** To clear an application\'s findings, use only the field `clearFindings` as the Request body and set it to true. Example:  ``` [    {      \"application\": {        \"applicationName\": \"Artemis\",        \"version\": \"Version 5.0\"      },      \"applicationFindings\": [        { \"clearFindings\": true }      ]    }  ] ```
         * @summary Upload static code scans or Clear static code scans
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {StaticCodeRequestPostBody} staticCodeRequestPostBody Add static code scans or Clear static code scans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addStaticCodeScansBySystemId: async (systemId: number, staticCodeRequestPostBody: StaticCodeRequestPostBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('addStaticCodeScansBySystemId', 'systemId', systemId)
            // verify required parameter 'staticCodeRequestPostBody' is not null or undefined
            assertParamExists('addStaticCodeScansBySystemId', 'staticCodeRequestPostBody', staticCodeRequestPostBody)
            const localVarPath = `/api/systems/{systemId}/static-code-scans`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(staticCodeRequestPostBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StaticCodeScansApi - functional programming interface
 * @export
 */
export const StaticCodeScansApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StaticCodeScansApiAxiosParamCreator(configuration)
    return {
        /**
         * Upload or clear application scan findings into a system\'s `systemId` assets module.  **Note:** To clear an application\'s findings, use only the field `clearFindings` as the Request body and set it to true. Example:  ``` [    {      \"application\": {        \"applicationName\": \"Artemis\",        \"version\": \"Version 5.0\"      },      \"applicationFindings\": [        { \"clearFindings\": true }      ]    }  ] ```
         * @summary Upload static code scans or Clear static code scans
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {StaticCodeRequestPostBody} staticCodeRequestPostBody Add static code scans or Clear static code scans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addStaticCodeScansBySystemId(systemId: number, staticCodeRequestPostBody: StaticCodeRequestPostBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaticCodeResponsePost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addStaticCodeScansBySystemId(systemId, staticCodeRequestPostBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StaticCodeScansApi - factory interface
 * @export
 */
export const StaticCodeScansApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StaticCodeScansApiFp(configuration)
    return {
        /**
         * Upload or clear application scan findings into a system\'s `systemId` assets module.  **Note:** To clear an application\'s findings, use only the field `clearFindings` as the Request body and set it to true. Example:  ``` [    {      \"application\": {        \"applicationName\": \"Artemis\",        \"version\": \"Version 5.0\"      },      \"applicationFindings\": [        { \"clearFindings\": true }      ]    }  ] ```
         * @summary Upload static code scans or Clear static code scans
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {StaticCodeRequestPostBody} staticCodeRequestPostBody Add static code scans or Clear static code scans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addStaticCodeScansBySystemId(systemId: number, staticCodeRequestPostBody: StaticCodeRequestPostBody, options?: any): AxiosPromise<StaticCodeResponsePost> {
            return localVarFp.addStaticCodeScansBySystemId(systemId, staticCodeRequestPostBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StaticCodeScansApi - object-oriented interface
 * @export
 * @class StaticCodeScansApi
 * @extends {BaseAPI}
 */
export class StaticCodeScansApi extends BaseAPI {
    /**
     * Upload or clear application scan findings into a system\'s `systemId` assets module.  **Note:** To clear an application\'s findings, use only the field `clearFindings` as the Request body and set it to true. Example:  ``` [    {      \"application\": {        \"applicationName\": \"Artemis\",        \"version\": \"Version 5.0\"      },      \"applicationFindings\": [        { \"clearFindings\": true }      ]    }  ] ```
     * @summary Upload static code scans or Clear static code scans
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {StaticCodeRequestPostBody} staticCodeRequestPostBody Add static code scans or Clear static code scans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaticCodeScansApi
     */
    public addStaticCodeScansBySystemId(systemId: number, staticCodeRequestPostBody: StaticCodeRequestPostBody, options?: AxiosRequestConfig) {
        return StaticCodeScansApiFp(this.configuration).addStaticCodeScansBySystemId(systemId, staticCodeRequestPostBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemRolesApi - axios parameter creator
 * @export
 */
export const SystemRolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all available roles
         * @summary Get available roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemRoles: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/system-roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the role(s) data matching parameters.
         * @summary Get system roles
         * @param {'CAC' | 'PAC' | 'Other'} roleCategory **Role Category**: The system role category been queried
         * @param {'AO' | 'Auditor' | 'Artifact Manager' | 'C&A Team' | 'IAO' | 'ISSO' | 'PM/IAM' | 'SCA' | 'User Rep' | 'Validator'} role **Role**: Accepts single value from options available at base system-roles endpoint e.g., SCA.
         * @param {'diacap' | 'rmf' | 'reporting'} [policy] **System Policy**: Filter query by system policy. If no value is specified and more than one policy is available, the default return is the RMF policy information.
         * @param {boolean} [includeDecommissioned] **Include Decommissioned Systems**: Indicates if decommissioned systems are retrieved. If no value is specified, the default returns true to include decommissioned systems.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemRolesByCategoryId: async (roleCategory: 'CAC' | 'PAC' | 'Other', role: 'AO' | 'Auditor' | 'Artifact Manager' | 'C&A Team' | 'IAO' | 'ISSO' | 'PM/IAM' | 'SCA' | 'User Rep' | 'Validator', policy?: 'diacap' | 'rmf' | 'reporting', includeDecommissioned?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleCategory' is not null or undefined
            assertParamExists('getSystemRolesByCategoryId', 'roleCategory', roleCategory)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('getSystemRolesByCategoryId', 'role', role)
            const localVarPath = `/api/system-roles/{roleCategory}`
                .replace(`{${"roleCategory"}}`, encodeURIComponent(String(roleCategory)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (policy !== undefined) {
                localVarQueryParameter['policy'] = policy;
            }

            if (includeDecommissioned !== undefined) {
                localVarQueryParameter['includeDecommissioned'] = includeDecommissioned;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemRolesApi - functional programming interface
 * @export
 */
export const SystemRolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemRolesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all available roles
         * @summary Get available roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemRoles(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemRolesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemRoles(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the role(s) data matching parameters.
         * @summary Get system roles
         * @param {'CAC' | 'PAC' | 'Other'} roleCategory **Role Category**: The system role category been queried
         * @param {'AO' | 'Auditor' | 'Artifact Manager' | 'C&A Team' | 'IAO' | 'ISSO' | 'PM/IAM' | 'SCA' | 'User Rep' | 'Validator'} role **Role**: Accepts single value from options available at base system-roles endpoint e.g., SCA.
         * @param {'diacap' | 'rmf' | 'reporting'} [policy] **System Policy**: Filter query by system policy. If no value is specified and more than one policy is available, the default return is the RMF policy information.
         * @param {boolean} [includeDecommissioned] **Include Decommissioned Systems**: Indicates if decommissioned systems are retrieved. If no value is specified, the default returns true to include decommissioned systems.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemRolesByCategoryId(roleCategory: 'CAC' | 'PAC' | 'Other', role: 'AO' | 'Auditor' | 'Artifact Manager' | 'C&A Team' | 'IAO' | 'ISSO' | 'PM/IAM' | 'SCA' | 'User Rep' | 'Validator', policy?: 'diacap' | 'rmf' | 'reporting', includeDecommissioned?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemRolesCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemRolesByCategoryId(roleCategory, role, policy, includeDecommissioned, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemRolesApi - factory interface
 * @export
 */
export const SystemRolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemRolesApiFp(configuration)
    return {
        /**
         * Returns all available roles
         * @summary Get available roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemRoles(options?: any): AxiosPromise<SystemRolesResponse> {
            return localVarFp.getSystemRoles(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the role(s) data matching parameters.
         * @summary Get system roles
         * @param {'CAC' | 'PAC' | 'Other'} roleCategory **Role Category**: The system role category been queried
         * @param {'AO' | 'Auditor' | 'Artifact Manager' | 'C&A Team' | 'IAO' | 'ISSO' | 'PM/IAM' | 'SCA' | 'User Rep' | 'Validator'} role **Role**: Accepts single value from options available at base system-roles endpoint e.g., SCA.
         * @param {'diacap' | 'rmf' | 'reporting'} [policy] **System Policy**: Filter query by system policy. If no value is specified and more than one policy is available, the default return is the RMF policy information.
         * @param {boolean} [includeDecommissioned] **Include Decommissioned Systems**: Indicates if decommissioned systems are retrieved. If no value is specified, the default returns true to include decommissioned systems.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemRolesByCategoryId(roleCategory: 'CAC' | 'PAC' | 'Other', role: 'AO' | 'Auditor' | 'Artifact Manager' | 'C&A Team' | 'IAO' | 'ISSO' | 'PM/IAM' | 'SCA' | 'User Rep' | 'Validator', policy?: 'diacap' | 'rmf' | 'reporting', includeDecommissioned?: boolean, options?: any): AxiosPromise<SystemRolesCategoryResponse> {
            return localVarFp.getSystemRolesByCategoryId(roleCategory, role, policy, includeDecommissioned, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemRolesApi - object-oriented interface
 * @export
 * @class SystemRolesApi
 * @extends {BaseAPI}
 */
export class SystemRolesApi extends BaseAPI {
    /**
     * Returns all available roles
     * @summary Get available roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemRolesApi
     */
    public getSystemRoles(options?: AxiosRequestConfig) {
        return SystemRolesApiFp(this.configuration).getSystemRoles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the role(s) data matching parameters.
     * @summary Get system roles
     * @param {'CAC' | 'PAC' | 'Other'} roleCategory **Role Category**: The system role category been queried
     * @param {'AO' | 'Auditor' | 'Artifact Manager' | 'C&A Team' | 'IAO' | 'ISSO' | 'PM/IAM' | 'SCA' | 'User Rep' | 'Validator'} role **Role**: Accepts single value from options available at base system-roles endpoint e.g., SCA.
     * @param {'diacap' | 'rmf' | 'reporting'} [policy] **System Policy**: Filter query by system policy. If no value is specified and more than one policy is available, the default return is the RMF policy information.
     * @param {boolean} [includeDecommissioned] **Include Decommissioned Systems**: Indicates if decommissioned systems are retrieved. If no value is specified, the default returns true to include decommissioned systems.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemRolesApi
     */
    public getSystemRolesByCategoryId(roleCategory: 'CAC' | 'PAC' | 'Other', role: 'AO' | 'Auditor' | 'Artifact Manager' | 'C&A Team' | 'IAO' | 'ISSO' | 'PM/IAM' | 'SCA' | 'User Rep' | 'Validator', policy?: 'diacap' | 'rmf' | 'reporting', includeDecommissioned?: boolean, options?: AxiosRequestConfig) {
        return SystemRolesApiFp(this.configuration).getSystemRolesByCategoryId(roleCategory, role, policy, includeDecommissioned, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemsApi - axios parameter creator
 * @export
 */
export const SystemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the system matching provided parameters
         * @summary Get system information for a specific system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {boolean} [includePackage] **Include Package**:  Indicates if additional packages information is retrieved for queried system.
         * @param {'diacap' | 'rmf' | 'reporting'} [policy] **System Policy**: Filter query by system policy. If no value is specified and more than one policy is available, the default return is the RMF policy information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystem: async (systemId: number, includePackage?: boolean, policy?: 'diacap' | 'rmf' | 'reporting', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('getSystem', 'systemId', systemId)
            const localVarPath = `/api/systems/{systemId}`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)

            if (includePackage !== undefined) {
                localVarQueryParameter['includePackage'] = includePackage;
            }

            if (policy !== undefined) {
                localVarQueryParameter['policy'] = policy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all system(s) that match the query parameters
         * @summary Get system information
         * @param {boolean} [includePackage] **Include Package**:  Indicates if additional packages information is retrieved for queried system.
         * @param {string} [registrationType] **Registration Type**: Filter record by selected registration type (single value or comma delimited values).  *Available values:* assessAndAuthorize, assessOnly, guest, regular, functional, cloudServiceProvider, commonControlProvider  
         * @param {string} [ditprId] **DITPR ID**: Filter query by DoD Information Technology (IT) Portfolio Repository (DITPR).
         * @param {string} [coamsId] **COAMS ID**: Filter query by Cyber Operational Attributes Management System (COAMS).
         * @param {'diacap' | 'rmf' | 'reporting'} [policy] **System Policy**: Filter query by system policy. If no value is specified and more than one policy is available, the default return is the RMF policy information.
         * @param {boolean} [includeDitprMetrics] **Include DITPR**: Indicates if DITPR metrics are retrieved. This query string parameter can only be used in conjunction with the following parameters:&lt;br&gt;   &lt;ul&gt;     &lt;li&gt;registrationType&lt;/li&gt;     &lt;li&gt;policy&lt;/li&gt;   &lt;/ul&gt;
         * @param {boolean} [includeDecommissioned] **Include Decommissioned Systems**: Indicates if decommissioned systems are retrieved. If no value is specified, the default returns true to include decommissioned systems.
         * @param {boolean} [reportsForScorecard] **DoD Cyber Hygiene Scorecard**: Indicates if the system reports to the DoD Cyber Hygiene Scorecard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystems: async (includePackage?: boolean, registrationType?: string, ditprId?: string, coamsId?: string, policy?: 'diacap' | 'rmf' | 'reporting', includeDitprMetrics?: boolean, includeDecommissioned?: boolean, reportsForScorecard?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/systems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)

            if (includePackage !== undefined) {
                localVarQueryParameter['includePackage'] = includePackage;
            }

            if (registrationType !== undefined) {
                localVarQueryParameter['registrationType'] = registrationType;
            }

            if (ditprId !== undefined) {
                localVarQueryParameter['ditprId'] = ditprId;
            }

            if (coamsId !== undefined) {
                localVarQueryParameter['coamsId'] = coamsId;
            }

            if (policy !== undefined) {
                localVarQueryParameter['policy'] = policy;
            }

            if (includeDitprMetrics !== undefined) {
                localVarQueryParameter['includeDitprMetrics'] = includeDitprMetrics;
            }

            if (includeDecommissioned !== undefined) {
                localVarQueryParameter['includeDecommissioned'] = includeDecommissioned;
            }

            if (reportsForScorecard !== undefined) {
                localVarQueryParameter['reportsForScorecard'] = reportsForScorecard;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemsApi - functional programming interface
 * @export
 */
export const SystemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the system matching provided parameters
         * @summary Get system information for a specific system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {boolean} [includePackage] **Include Package**:  Indicates if additional packages information is retrieved for queried system.
         * @param {'diacap' | 'rmf' | 'reporting'} [policy] **System Policy**: Filter query by system policy. If no value is specified and more than one policy is available, the default return is the RMF policy information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystem(systemId: number, includePackage?: boolean, policy?: 'diacap' | 'rmf' | 'reporting', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystem(systemId, includePackage, policy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all system(s) that match the query parameters
         * @summary Get system information
         * @param {boolean} [includePackage] **Include Package**:  Indicates if additional packages information is retrieved for queried system.
         * @param {string} [registrationType] **Registration Type**: Filter record by selected registration type (single value or comma delimited values).  *Available values:* assessAndAuthorize, assessOnly, guest, regular, functional, cloudServiceProvider, commonControlProvider  
         * @param {string} [ditprId] **DITPR ID**: Filter query by DoD Information Technology (IT) Portfolio Repository (DITPR).
         * @param {string} [coamsId] **COAMS ID**: Filter query by Cyber Operational Attributes Management System (COAMS).
         * @param {'diacap' | 'rmf' | 'reporting'} [policy] **System Policy**: Filter query by system policy. If no value is specified and more than one policy is available, the default return is the RMF policy information.
         * @param {boolean} [includeDitprMetrics] **Include DITPR**: Indicates if DITPR metrics are retrieved. This query string parameter can only be used in conjunction with the following parameters:&lt;br&gt;   &lt;ul&gt;     &lt;li&gt;registrationType&lt;/li&gt;     &lt;li&gt;policy&lt;/li&gt;   &lt;/ul&gt;
         * @param {boolean} [includeDecommissioned] **Include Decommissioned Systems**: Indicates if decommissioned systems are retrieved. If no value is specified, the default returns true to include decommissioned systems.
         * @param {boolean} [reportsForScorecard] **DoD Cyber Hygiene Scorecard**: Indicates if the system reports to the DoD Cyber Hygiene Scorecard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystems(includePackage?: boolean, registrationType?: string, ditprId?: string, coamsId?: string, policy?: 'diacap' | 'rmf' | 'reporting', includeDitprMetrics?: boolean, includeDecommissioned?: boolean, reportsForScorecard?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystems(includePackage, registrationType, ditprId, coamsId, policy, includeDitprMetrics, includeDecommissioned, reportsForScorecard, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemsApi - factory interface
 * @export
 */
export const SystemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemsApiFp(configuration)
    return {
        /**
         * Returns the system matching provided parameters
         * @summary Get system information for a specific system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {boolean} [includePackage] **Include Package**:  Indicates if additional packages information is retrieved for queried system.
         * @param {'diacap' | 'rmf' | 'reporting'} [policy] **System Policy**: Filter query by system policy. If no value is specified and more than one policy is available, the default return is the RMF policy information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystem(systemId: number, includePackage?: boolean, policy?: 'diacap' | 'rmf' | 'reporting', options?: any): AxiosPromise<SystemResponse> {
            return localVarFp.getSystem(systemId, includePackage, policy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all system(s) that match the query parameters
         * @summary Get system information
         * @param {boolean} [includePackage] **Include Package**:  Indicates if additional packages information is retrieved for queried system.
         * @param {string} [registrationType] **Registration Type**: Filter record by selected registration type (single value or comma delimited values).  *Available values:* assessAndAuthorize, assessOnly, guest, regular, functional, cloudServiceProvider, commonControlProvider  
         * @param {string} [ditprId] **DITPR ID**: Filter query by DoD Information Technology (IT) Portfolio Repository (DITPR).
         * @param {string} [coamsId] **COAMS ID**: Filter query by Cyber Operational Attributes Management System (COAMS).
         * @param {'diacap' | 'rmf' | 'reporting'} [policy] **System Policy**: Filter query by system policy. If no value is specified and more than one policy is available, the default return is the RMF policy information.
         * @param {boolean} [includeDitprMetrics] **Include DITPR**: Indicates if DITPR metrics are retrieved. This query string parameter can only be used in conjunction with the following parameters:&lt;br&gt;   &lt;ul&gt;     &lt;li&gt;registrationType&lt;/li&gt;     &lt;li&gt;policy&lt;/li&gt;   &lt;/ul&gt;
         * @param {boolean} [includeDecommissioned] **Include Decommissioned Systems**: Indicates if decommissioned systems are retrieved. If no value is specified, the default returns true to include decommissioned systems.
         * @param {boolean} [reportsForScorecard] **DoD Cyber Hygiene Scorecard**: Indicates if the system reports to the DoD Cyber Hygiene Scorecard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystems(includePackage?: boolean, registrationType?: string, ditprId?: string, coamsId?: string, policy?: 'diacap' | 'rmf' | 'reporting', includeDitprMetrics?: boolean, includeDecommissioned?: boolean, reportsForScorecard?: boolean, options?: any): AxiosPromise<SystemsResponse> {
            return localVarFp.getSystems(includePackage, registrationType, ditprId, coamsId, policy, includeDitprMetrics, includeDecommissioned, reportsForScorecard, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemsApi - object-oriented interface
 * @export
 * @class SystemsApi
 * @extends {BaseAPI}
 */
export class SystemsApi extends BaseAPI {
    /**
     * Returns the system matching provided parameters
     * @summary Get system information for a specific system
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {boolean} [includePackage] **Include Package**:  Indicates if additional packages information is retrieved for queried system.
     * @param {'diacap' | 'rmf' | 'reporting'} [policy] **System Policy**: Filter query by system policy. If no value is specified and more than one policy is available, the default return is the RMF policy information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public getSystem(systemId: number, includePackage?: boolean, policy?: 'diacap' | 'rmf' | 'reporting', options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).getSystem(systemId, includePackage, policy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all system(s) that match the query parameters
     * @summary Get system information
     * @param {boolean} [includePackage] **Include Package**:  Indicates if additional packages information is retrieved for queried system.
     * @param {string} [registrationType] **Registration Type**: Filter record by selected registration type (single value or comma delimited values).  *Available values:* assessAndAuthorize, assessOnly, guest, regular, functional, cloudServiceProvider, commonControlProvider  
     * @param {string} [ditprId] **DITPR ID**: Filter query by DoD Information Technology (IT) Portfolio Repository (DITPR).
     * @param {string} [coamsId] **COAMS ID**: Filter query by Cyber Operational Attributes Management System (COAMS).
     * @param {'diacap' | 'rmf' | 'reporting'} [policy] **System Policy**: Filter query by system policy. If no value is specified and more than one policy is available, the default return is the RMF policy information.
     * @param {boolean} [includeDitprMetrics] **Include DITPR**: Indicates if DITPR metrics are retrieved. This query string parameter can only be used in conjunction with the following parameters:&lt;br&gt;   &lt;ul&gt;     &lt;li&gt;registrationType&lt;/li&gt;     &lt;li&gt;policy&lt;/li&gt;   &lt;/ul&gt;
     * @param {boolean} [includeDecommissioned] **Include Decommissioned Systems**: Indicates if decommissioned systems are retrieved. If no value is specified, the default returns true to include decommissioned systems.
     * @param {boolean} [reportsForScorecard] **DoD Cyber Hygiene Scorecard**: Indicates if the system reports to the DoD Cyber Hygiene Scorecard.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public getSystems(includePackage?: boolean, registrationType?: string, ditprId?: string, coamsId?: string, policy?: 'diacap' | 'rmf' | 'reporting', includeDitprMetrics?: boolean, includeDecommissioned?: boolean, reportsForScorecard?: boolean, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).getSystems(includePackage, registrationType, ditprId, coamsId, policy, includeDitprMetrics, includeDecommissioned, reportsForScorecard, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestApi - axios parameter creator
 * @export
 */
export const TestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns endpoint call status
         * @summary Test connection to the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testConnection: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestApi - functional programming interface
 * @export
 */
export const TestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns endpoint call status
         * @summary Test connection to the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testConnection(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Test>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testConnection(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TestApi - factory interface
 * @export
 */
export const TestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestApiFp(configuration)
    return {
        /**
         * Returns endpoint call status
         * @summary Test connection to the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testConnection(options?: any): AxiosPromise<Test> {
            return localVarFp.testConnection(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestApi - object-oriented interface
 * @export
 * @class TestApi
 * @extends {BaseAPI}
 */
export class TestApi extends BaseAPI {
    /**
     * Returns endpoint call status
     * @summary Test connection to the API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public testConnection(options?: AxiosRequestConfig) {
        return TestApiFp(this.configuration).testConnection(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestResultsApi - axios parameter creator
 * @export
 */
export const TestResultsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds test results for given `systemId`  **Request Body Required Fields** - `cci` - `testedBy` - `testDate` - `description` - `complianceStatus`
         * @summary Add one or many test results in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Add test results to a system (systemId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTestResultsBySystemId: async (systemId: number, requestBody: Array<object>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('addTestResultsBySystemId', 'systemId', systemId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('addTestResultsBySystemId', 'requestBody', requestBody)
            const localVarPath = `/api/systems/{systemId}/test-results`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns system test results information for matching parameters.<br>
         * @summary Get one or many test results in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {string} [controlAcronyms] **System Acronym**: Filter query by given system acronym (single or comma separated).
         * @param {string} [ccis] **CCI System**: Filter query by Control Correlation Identifiers (CCIs) (single or comma separated).
         * @param {boolean} [latestOnly] **Latest Results Only**: Indicates that only the latest test resultes are retrieved (single or comma separated).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemTestResults: async (systemId: number, controlAcronyms?: string, ccis?: string, latestOnly?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('getSystemTestResults', 'systemId', systemId)
            const localVarPath = `/api/systems/{systemId}/test-results`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)

            if (controlAcronyms !== undefined) {
                localVarQueryParameter['controlAcronyms'] = controlAcronyms;
            }

            if (ccis !== undefined) {
                localVarQueryParameter['ccis'] = ccis;
            }

            if (latestOnly !== undefined) {
                localVarQueryParameter['latestOnly'] = latestOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestResultsApi - functional programming interface
 * @export
 */
export const TestResultsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestResultsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds test results for given `systemId`  **Request Body Required Fields** - `cci` - `testedBy` - `testDate` - `description` - `complianceStatus`
         * @summary Add one or many test results in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Add test results to a system (systemId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTestResultsBySystemId(systemId: number, requestBody: Array<object>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResultsResponsePost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTestResultsBySystemId(systemId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns system test results information for matching parameters.<br>
         * @summary Get one or many test results in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {string} [controlAcronyms] **System Acronym**: Filter query by given system acronym (single or comma separated).
         * @param {string} [ccis] **CCI System**: Filter query by Control Correlation Identifiers (CCIs) (single or comma separated).
         * @param {boolean} [latestOnly] **Latest Results Only**: Indicates that only the latest test resultes are retrieved (single or comma separated).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemTestResults(systemId: number, controlAcronyms?: string, ccis?: string, latestOnly?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResultsResponseGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemTestResults(systemId, controlAcronyms, ccis, latestOnly, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TestResultsApi - factory interface
 * @export
 */
export const TestResultsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestResultsApiFp(configuration)
    return {
        /**
         * Adds test results for given `systemId`  **Request Body Required Fields** - `cci` - `testedBy` - `testDate` - `description` - `complianceStatus`
         * @summary Add one or many test results in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {Array<object>} requestBody Add test results to a system (systemId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTestResultsBySystemId(systemId: number, requestBody: Array<object>, options?: any): AxiosPromise<TestResultsResponsePost> {
            return localVarFp.addTestResultsBySystemId(systemId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns system test results information for matching parameters.<br>
         * @summary Get one or many test results in a system
         * @param {number} systemId **System Id**: The unique system record identifier.
         * @param {string} [controlAcronyms] **System Acronym**: Filter query by given system acronym (single or comma separated).
         * @param {string} [ccis] **CCI System**: Filter query by Control Correlation Identifiers (CCIs) (single or comma separated).
         * @param {boolean} [latestOnly] **Latest Results Only**: Indicates that only the latest test resultes are retrieved (single or comma separated).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemTestResults(systemId: number, controlAcronyms?: string, ccis?: string, latestOnly?: boolean, options?: any): AxiosPromise<TestResultsResponseGet> {
            return localVarFp.getSystemTestResults(systemId, controlAcronyms, ccis, latestOnly, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestResultsApi - object-oriented interface
 * @export
 * @class TestResultsApi
 * @extends {BaseAPI}
 */
export class TestResultsApi extends BaseAPI {
    /**
     * Adds test results for given `systemId`  **Request Body Required Fields** - `cci` - `testedBy` - `testDate` - `description` - `complianceStatus`
     * @summary Add one or many test results in a system
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {Array<object>} requestBody Add test results to a system (systemId)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestResultsApi
     */
    public addTestResultsBySystemId(systemId: number, requestBody: Array<object>, options?: AxiosRequestConfig) {
        return TestResultsApiFp(this.configuration).addTestResultsBySystemId(systemId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns system test results information for matching parameters.<br>
     * @summary Get one or many test results in a system
     * @param {number} systemId **System Id**: The unique system record identifier.
     * @param {string} [controlAcronyms] **System Acronym**: Filter query by given system acronym (single or comma separated).
     * @param {string} [ccis] **CCI System**: Filter query by Control Correlation Identifiers (CCIs) (single or comma separated).
     * @param {boolean} [latestOnly] **Latest Results Only**: Indicates that only the latest test resultes are retrieved (single or comma separated).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestResultsApi
     */
    public getSystemTestResults(systemId: number, controlAcronyms?: string, ccis?: string, latestOnly?: boolean, options?: AxiosRequestConfig) {
        return TestResultsApiFp(this.configuration).getSystemTestResults(systemId, controlAcronyms, ccis, latestOnly, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkflowDefinitionsApi - axios parameter creator
 * @export
 */
export const WorkflowDefinitionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * View all workflow schemas available on the eMASS instance filtered by  status `includeInactive` and registration type `registrationType`.
         * @summary Get workflow definitions in a site
         * @param {boolean} [includeInactive] **Include Inactive**: If no value is specified, the default returns false to not include outdated workflow definitions.
         * @param {string} [registrationType] **Registration Type**: Filter record by selected registration type (single value or comma delimited values).  *Available values:* assessAndAuthorize, assessOnly, guest, regular, functional, cloudServiceProvider, commonControlProvider  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowDefinitions: async (includeInactive?: boolean, registrationType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/workflows/definitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)

            if (includeInactive !== undefined) {
                localVarQueryParameter['includeInactive'] = includeInactive;
            }

            if (registrationType !== undefined) {
                localVarQueryParameter['registrationType'] = registrationType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowDefinitionsApi - functional programming interface
 * @export
 */
export const WorkflowDefinitionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowDefinitionsApiAxiosParamCreator(configuration)
    return {
        /**
         * View all workflow schemas available on the eMASS instance filtered by  status `includeInactive` and registration type `registrationType`.
         * @summary Get workflow definitions in a site
         * @param {boolean} [includeInactive] **Include Inactive**: If no value is specified, the default returns false to not include outdated workflow definitions.
         * @param {string} [registrationType] **Registration Type**: Filter record by selected registration type (single value or comma delimited values).  *Available values:* assessAndAuthorize, assessOnly, guest, regular, functional, cloudServiceProvider, commonControlProvider  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowDefinitions(includeInactive?: boolean, registrationType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowDefinitionResponseGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowDefinitions(includeInactive, registrationType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkflowDefinitionsApi - factory interface
 * @export
 */
export const WorkflowDefinitionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowDefinitionsApiFp(configuration)
    return {
        /**
         * View all workflow schemas available on the eMASS instance filtered by  status `includeInactive` and registration type `registrationType`.
         * @summary Get workflow definitions in a site
         * @param {boolean} [includeInactive] **Include Inactive**: If no value is specified, the default returns false to not include outdated workflow definitions.
         * @param {string} [registrationType] **Registration Type**: Filter record by selected registration type (single value or comma delimited values).  *Available values:* assessAndAuthorize, assessOnly, guest, regular, functional, cloudServiceProvider, commonControlProvider  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowDefinitions(includeInactive?: boolean, registrationType?: string, options?: any): AxiosPromise<WorkflowDefinitionResponseGet> {
            return localVarFp.getWorkflowDefinitions(includeInactive, registrationType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowDefinitionsApi - object-oriented interface
 * @export
 * @class WorkflowDefinitionsApi
 * @extends {BaseAPI}
 */
export class WorkflowDefinitionsApi extends BaseAPI {
    /**
     * View all workflow schemas available on the eMASS instance filtered by  status `includeInactive` and registration type `registrationType`.
     * @summary Get workflow definitions in a site
     * @param {boolean} [includeInactive] **Include Inactive**: If no value is specified, the default returns false to not include outdated workflow definitions.
     * @param {string} [registrationType] **Registration Type**: Filter record by selected registration type (single value or comma delimited values).  *Available values:* assessAndAuthorize, assessOnly, guest, regular, functional, cloudServiceProvider, commonControlProvider  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowDefinitionsApi
     */
    public getWorkflowDefinitions(includeInactive?: boolean, registrationType?: string, options?: AxiosRequestConfig) {
        return WorkflowDefinitionsApiFp(this.configuration).getWorkflowDefinitions(includeInactive, registrationType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkflowInstancesApi - axios parameter creator
 * @export
 */
export const WorkflowInstancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * View detailed information on all active and historical workflows filtered by provided parameters.
         * @summary Get workflow instances in a site
         * @param {boolean} [includeComments] **Include Comments**: If no value is specified, the default returns true to not include transition comments.  Note: Corresponds to the Comments textbox that is required at most workflow transitions. Does not include other text input fields such as Terms / Conditions for Authorization. 
         * @param {number} [pageIndex] **Page Index**: If no value is specified, the default returns true to not include transition comments.
         * @param {string} [sinceDate] **Date**: Filter on authorization/assessment date (Unix date format).  Note: Filters off the lastEditedDate field.  Note: The authorization/assessment decisions on completed workflows  can be edited for up to 30 days after the initial decision is made. 
         * @param {'active' | 'inactive' | 'all'} [status] **Status**: Filter by status.  If no value is specified, the default returns all to include both active and inactive workflows.  Note: Any workflows at a current stage of Complete or Cancelled are inactive. Ongoing workflows currently at other stages are active. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemWorkflowInstances: async (includeComments?: boolean, pageIndex?: number, sinceDate?: string, status?: 'active' | 'inactive' | 'all', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/workflows/instances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)

            if (includeComments !== undefined) {
                localVarQueryParameter['includeComments'] = includeComments;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (sinceDate !== undefined) {
                localVarQueryParameter['sinceDate'] = sinceDate;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View detailed historical workflow information for `workflowInstanceId`.
         * @summary Get workflow instance by ID
         * @param {number} workflowInstanceId **Workflow Instance Id**: The unique workflow definition identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemWorkflowInstancesByWorkflowInstanceId: async (workflowInstanceId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowInstanceId' is not null or undefined
            assertParamExists('getSystemWorkflowInstancesByWorkflowInstanceId', 'workflowInstanceId', workflowInstanceId)
            const localVarPath = `/api/workflows/instances/{workflowInstanceId}`
                .replace(`{${"workflowInstanceId"}}`, encodeURIComponent(String(workflowInstanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication mockType required
            await setApiKeyToObject(localVarHeaderParameter, "Prefer", configuration)

            // authentication userId required
            await setApiKeyToObject(localVarHeaderParameter, "user-uid", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowInstancesApi - functional programming interface
 * @export
 */
export const WorkflowInstancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowInstancesApiAxiosParamCreator(configuration)
    return {
        /**
         * View detailed information on all active and historical workflows filtered by provided parameters.
         * @summary Get workflow instances in a site
         * @param {boolean} [includeComments] **Include Comments**: If no value is specified, the default returns true to not include transition comments.  Note: Corresponds to the Comments textbox that is required at most workflow transitions. Does not include other text input fields such as Terms / Conditions for Authorization. 
         * @param {number} [pageIndex] **Page Index**: If no value is specified, the default returns true to not include transition comments.
         * @param {string} [sinceDate] **Date**: Filter on authorization/assessment date (Unix date format).  Note: Filters off the lastEditedDate field.  Note: The authorization/assessment decisions on completed workflows  can be edited for up to 30 days after the initial decision is made. 
         * @param {'active' | 'inactive' | 'all'} [status] **Status**: Filter by status.  If no value is specified, the default returns all to include both active and inactive workflows.  Note: Any workflows at a current stage of Complete or Cancelled are inactive. Ongoing workflows currently at other stages are active. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemWorkflowInstances(includeComments?: boolean, pageIndex?: number, sinceDate?: string, status?: 'active' | 'inactive' | 'all', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowInstancesResponseGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemWorkflowInstances(includeComments, pageIndex, sinceDate, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * View detailed historical workflow information for `workflowInstanceId`.
         * @summary Get workflow instance by ID
         * @param {number} workflowInstanceId **Workflow Instance Id**: The unique workflow definition identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemWorkflowInstancesByWorkflowInstanceId(workflowInstanceId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowInstanceResponseGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemWorkflowInstancesByWorkflowInstanceId(workflowInstanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkflowInstancesApi - factory interface
 * @export
 */
export const WorkflowInstancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowInstancesApiFp(configuration)
    return {
        /**
         * View detailed information on all active and historical workflows filtered by provided parameters.
         * @summary Get workflow instances in a site
         * @param {boolean} [includeComments] **Include Comments**: If no value is specified, the default returns true to not include transition comments.  Note: Corresponds to the Comments textbox that is required at most workflow transitions. Does not include other text input fields such as Terms / Conditions for Authorization. 
         * @param {number} [pageIndex] **Page Index**: If no value is specified, the default returns true to not include transition comments.
         * @param {string} [sinceDate] **Date**: Filter on authorization/assessment date (Unix date format).  Note: Filters off the lastEditedDate field.  Note: The authorization/assessment decisions on completed workflows  can be edited for up to 30 days after the initial decision is made. 
         * @param {'active' | 'inactive' | 'all'} [status] **Status**: Filter by status.  If no value is specified, the default returns all to include both active and inactive workflows.  Note: Any workflows at a current stage of Complete or Cancelled are inactive. Ongoing workflows currently at other stages are active. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemWorkflowInstances(includeComments?: boolean, pageIndex?: number, sinceDate?: string, status?: 'active' | 'inactive' | 'all', options?: any): AxiosPromise<WorkflowInstancesResponseGet> {
            return localVarFp.getSystemWorkflowInstances(includeComments, pageIndex, sinceDate, status, options).then((request) => request(axios, basePath));
        },
        /**
         * View detailed historical workflow information for `workflowInstanceId`.
         * @summary Get workflow instance by ID
         * @param {number} workflowInstanceId **Workflow Instance Id**: The unique workflow definition identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemWorkflowInstancesByWorkflowInstanceId(workflowInstanceId: number, options?: any): AxiosPromise<WorkflowInstanceResponseGet> {
            return localVarFp.getSystemWorkflowInstancesByWorkflowInstanceId(workflowInstanceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowInstancesApi - object-oriented interface
 * @export
 * @class WorkflowInstancesApi
 * @extends {BaseAPI}
 */
export class WorkflowInstancesApi extends BaseAPI {
    /**
     * View detailed information on all active and historical workflows filtered by provided parameters.
     * @summary Get workflow instances in a site
     * @param {boolean} [includeComments] **Include Comments**: If no value is specified, the default returns true to not include transition comments.  Note: Corresponds to the Comments textbox that is required at most workflow transitions. Does not include other text input fields such as Terms / Conditions for Authorization. 
     * @param {number} [pageIndex] **Page Index**: If no value is specified, the default returns true to not include transition comments.
     * @param {string} [sinceDate] **Date**: Filter on authorization/assessment date (Unix date format).  Note: Filters off the lastEditedDate field.  Note: The authorization/assessment decisions on completed workflows  can be edited for up to 30 days after the initial decision is made. 
     * @param {'active' | 'inactive' | 'all'} [status] **Status**: Filter by status.  If no value is specified, the default returns all to include both active and inactive workflows.  Note: Any workflows at a current stage of Complete or Cancelled are inactive. Ongoing workflows currently at other stages are active. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowInstancesApi
     */
    public getSystemWorkflowInstances(includeComments?: boolean, pageIndex?: number, sinceDate?: string, status?: 'active' | 'inactive' | 'all', options?: AxiosRequestConfig) {
        return WorkflowInstancesApiFp(this.configuration).getSystemWorkflowInstances(includeComments, pageIndex, sinceDate, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View detailed historical workflow information for `workflowInstanceId`.
     * @summary Get workflow instance by ID
     * @param {number} workflowInstanceId **Workflow Instance Id**: The unique workflow definition identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowInstancesApi
     */
    public getSystemWorkflowInstancesByWorkflowInstanceId(workflowInstanceId: number, options?: AxiosRequestConfig) {
        return WorkflowInstancesApiFp(this.configuration).getSystemWorkflowInstancesByWorkflowInstanceId(workflowInstanceId, options).then((request) => request(this.axios, this.basePath));
    }
}


